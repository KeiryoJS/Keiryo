// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@neocord/utils
//   ../@neocord/gateway
//   ../@neocord/rest
//   ../stream
//   ../discord-api-types/default

import type { BitField, BitFieldObject, Class, Collection, Emitter, Snowflake } from "@neocord/utils";
import type { GatewayEvent, InternalShard, InternalShardingManager, ISMOptions } from "@neocord/gateway";
import type { API, APIOptions, ImageURLOptions } from "@neocord/rest";
import type { Readable } from "stream";
import type {
  APIGuild,
  APIGuildWelcomeScreen,
  APIGuildWelcomeScreenChannel,
  APIUser,
  GuildExplicitContentFilter,
  GuildFeature,
  GuildPremiumTier,
  GuildSystemChannelFlags,
  GuildVerificationLevel,
  UserFlags,
  UserPremiumType
} from "discord-api-types/default";

export class CachingManager {
  /**
   * All providers.
   */
  readonly providers: CachingProvider[];
  /**
   * The client instance.
   */
  readonly client: Client;
  /**
   * The options passed.
   */
  readonly options: Required<CachingOptions>;
  /**
   * The disabled cacheables.
   */
  disabled: Set<Cacheable>;
  /**
   * The cacheable limits.
   */
  limits: Map<Cacheable, number>;

  /**
   * Creates a new instance of CachingManager.
   * @param client
   * @param options
   */
  constructor(client: Client, options?: CachingOptions);

  /**
   * Gets a cache.
   * @param cacheable
   * @param args
   */
  get(cacheable: Cacheable, ...args: unknown[]): Cache<any>;

  /**
   * Gets a provider from a cacheable.
   * @param cacheable The cacheable.
   */
  provider(cacheable: Cacheable): CachingProvider;
}

export interface CachingOptions {
  limit?: Map<Cacheable, number> | number;
  providers?: CachingProvider[];
  disable?: Cacheable[];
}

export class Cache<V extends Base> extends Collection<string, V> {
  /**
   * The provider instance.
   */
  readonly provider: CachingProvider;
  /**
   * The cacheable.
   */
  readonly cacheable: Cacheable;

  /**
   * Creates a new instanceof Cache.
   * @param provider The provider.
   * @param cacheable The thing we're caching.
   * @param args
   */
  constructor(provider: CachingProvider, cacheable: Cacheable, ...args: unknown[]);

  static get [Symbol.species](): typeof Cache;

  /**
   * Adds an entry to this cache.
   * @param key The entry key.
   * @param value The entry value.
   */
  set(key: string, value: V): this;
}

export class CachingProvider<C extends Cache<any> = Cache<any>> {
  caches: Cacheables;
  /**
   * The caching manager.
   */
  manager: CachingManager;
  /**
   * The cache class.
   * @private
   */
  protected _cache: typeof Cache;

  /**
   * Creates a new instance of CachingProvider.
   * @param options The caching options.
   */
  constructor(options: ProviderOptions);

  /**
   * Whether or not this provider caches everything.
   */
  get cachesAll(): boolean;

  /**
   * Returns whether or not a cacheable is disabled.
   * @param cacheable
   */
  isDisabled(cacheable: Cacheable): boolean;

  /**
   * Returns the limit for a certain cacheable.
   * @param cacheable The cacheable.
   */
  getLimit(cacheable: Cacheable): number;

  /**
   * Gets a new cache instance.
   * @param cacheable
   * @param args
   */
  get(cacheable: Cacheable, ...args: unknown[]): C;
}

export interface ProviderOptions {
  caches: CacheableResolvable;
  cache?: typeof Cache;
}

export class Client extends Emitter {
  /**
   * The user manager for this client.
   */
  readonly users: UserManager;
  /**
   * The guild manager for this client.
   */
  readonly guilds: GuildManager;
  /**
   * The current user.
   */
  user?: ClientUser;
  /**
   * The token of this client.
   */
  token: string;

  /**
   * Creates a new Client.
   * @param options
   */
  constructor(options?: ClientOptions);

  /**
   * The internal sharding manager instance.
   */
  get ws(): InternalShardingManager;

  /**
   * An interface for the discord api and cdn.
   */
  get api(): API;

  /**
   * The caching manager for this client.
   */
  get caching(): CachingManager;

  /**
   * Connects the bot to the discord gateway.
   */
  connect(token?: string): Promise<this>;

  /**
   * Destroys this client.
   */
  destroy(): void;
}

export interface ClientOptions {
  /**
   * Options for the sharding manager.
   */
  ws?: ISMOptions;
  /**
   * Options for the REST manager.
   */
  rest?: APIOptions;
  /**
   * Options for caching.
   */
  caching?: CachingOptions;
  /**
   * Tracks how many times a certain event is received.
   */
  track?: GatewayEvent[] | "all" | boolean;
}

export enum Permission {
  CreateInstanceInvite = 1,
  KickMembers = 2,
  BanMembers = 4,
  Administrator = 8,
  ManageChannels = 16,
  ManageGuild = 32,
  AddReactions = 64,
  ViewAuditLog = 128,
  PrioritySpeaker = 256,
  Stream = 512,
  ViewChannel = 1024,
  SendMessages = 2048,
  SendTTSMessage = 4096,
  MangeMessages = 8192,
  EmbedLinks = 16384,
  AttachFiles = 32768,
  ReadMessageHistory = 65536,
  MentionEveryone = 131072,
  UseExternalEmojis = 262144,
  ViewGuildInsights = 524288,
  Connect = 1048576,
  Speak = 2097152,
  MuteMembers = 4194304,
  DeafenMembers = 8388608,
  MoveMembers = 16777216,
  UseVAD = 33554432,
  ChangeNickname = 67108864,
  ManageNicknames = 134217728,
  ManageRoles = 268435456,
  ManageWebhooks = 536870912,
  ManageEmojis = 1073741824
}

export class Permissions extends BitField<PermissionResolvable> {
  /**
   * All Permission Flags.
   */
  static FLAGS: typeof Permission;
  /**
   * The default permissions for a role.
   */
  static DEFAULT: number;

  /**
   * Checks whether the bitfield has a permission, or any of multiple permissions.
   * @param permission Permission(s) to check for
   * @param checkAdmin Whether to allow the administrator permission to override
   */
  any(permission: PermissionResolvable, checkAdmin?: boolean): boolean;

  /**
   * Checks whether the bitfield has a permission, or multiple permissions.
   * @param permission Permission(s) to check for
   * @param checkAdmin Whether to allow the administrator permission to override
   */
  has(permission: PermissionResolvable, checkAdmin?: boolean): boolean;
}

export type PermissionResolvable =
  keyof typeof Permission
  | Permission
  | number
  | BitFieldObject
  | ((keyof typeof Permission) | number | BitFieldObject)[];

export enum Cacheable {
  Guild = 1,
  Message = 2,
  Role = 4,
  Member = 8,
  Overwrite = 16,
  VoiceState = 32,
  Presence = 64,
  DMChannel = 128,
  GuildChannel = 256,
  GuildEmoji = 512,
  User = 1024,
  Invite = 2048,
  PinnedMessage = 4096
}

export class Cacheables extends BitField<CacheableResolvable> {
  /**
   * All cacheable structures.
   */
  static FLAGS: typeof Cacheable;
}

export type CacheableResolvable =
  Cacheable
  | keyof Cacheable
  | number
  | BitFieldObject
  | ((keyof Cacheable) | number | BitFieldObject)[];

export abstract class ImageResolver {
  /**
   * Whether a buffer is of the jpeg format.
   * @param buffer
   */
  static isJpg(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the png format.
   * @param buffer
   */
  static isPng(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the webp format.
   * @param buffer
   */
  static isWebp(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the gif format
   * @param buffer
   */
  static isGif(buffer: Buffer): boolean;

  /**
   * Get the image format of a buffer.
   * @param buffer
   */
  static getImageFormat(buffer: Buffer): ImageFormats | null;

  /**
   * @param data
   */
  static resolveBase64(data: Buffer | string): string;

  /**
   * @param resource
   */
  static resolveFile(resource: ImageResolvable): Promise<Buffer>;

  /**
   * Resolve an image into a base64
   * @param data
   */
  static resolveImage(data: ImageResolvable): Promise<string>;
}

export type ImageResolvable = Buffer | Readable | string;

export enum ImageFormats {
  WEBP = "image/webp",
  GIF = "image/gif",
  PNG = "image/png",
  JPEG = "image/jpeg"
}

export function define(descriptor: Omit<PropertyDescriptor, "value" | "get" | "set">): PropertyDecorator;

export enum ClientEvent {
  GuildAvailable = "guildAvailable"
}

export abstract class Base {
  /**
   * The client instance.
   */
  readonly client: Client;
  /**
   * The ID of this instance.
   */
  abstract readonly id: string;

  /**
   * Creates a new instance of Base.
   * @param client The client instance.
   */
  protected constructor(client: Client);

  /**
   * Clones this instance.
   */
  clone(): this;

  /**
   * Get the JSON representation of this instance.4
   */
  toJSON(): Dictionary;

  /**
   * @protected
   */
  protected _patch(...data: unknown[]): this;
}

export class UserManager extends BaseManager<User> {
  /**
   * The user cache.
   * @protected
   */
  cache: Cache<User>;

  /**
   * Creates a new instanceof UserManager.
   * @param client The client instance.
   */
  constructor(client: Client);

  /**
   * Fetches a user from the discord api.
   * @param id The ID of the user to fetch.
   */
  fetch(id: string): Promise<User>;
}

export class GuildManager extends BaseManager<Guild> {
  /**
   * The guilds cache.
   * @protected
   */
  readonly cache: Cache<Guild>;

  /**
   * Creates a new instanceof GuildManager.
   * @param client The client instance.
   */
  constructor(client: Client);
}

export class ClientUser extends User {
  /**
   * Set the username of the current user.
   * @param username The new username.
   */
  setUsername(username: string): Promise<this>;

  /**
   * Update the current users avatar.
   * @param avatar The avatar to update the current one with.
   */
  setAvatar(avatar: ImageResolvable | null): Promise<this>;

  /**
   * Updates the current user.
   * @param data The new username or avatar to update the current user with.
   */
  update(data?: ClientUserUpdate): Promise<this>;
}

export interface ClientUserUpdate {
  username?: string;
  avatar?: ImageResolvable | null;
}

export abstract class BaseManager<T extends Base> extends Collection<string, T> {
  /**
   * The client instance.
   */
  readonly client: Client;
  /**
   * The thing this manager manages.
   */
  readonly manages: Class<T>;
  /**
   * The cache for this manager.
   * @protected
   */
  abstract readonly cache: Cache<T>;

  /**
   * Creates a new instance of BaseManager.
   * @param client The client instance.
   * @param structure
   */
  protected constructor(client: Client, structure: Class<T>);

  resolve(data: unknown): T | null;

  /**
   * Attempts to resolve an id from a value.
   * @param data
   */
  resolveId(data: unknown): string | null;

  /**
   * Gets an entry from the cache.
   * @param key The key of the entry to get.
   */
  get(key: string): T | undefined;

  /**
   * Sets an on the cache.
   * @param key The entry key.
   * @param value The entry value.
   */
  set(key: string, value: T): this;

  /**
   * All of the keys in the cache.
   */
  keys(): IterableIterator<string>;

  /**
   * All of the values in the cache.
   */
  values(): IterableIterator<T>;

  /**
   * All entries in the cache.
   */
  entries(): IterableIterator<[ string, T ]>;

  /**
   * The json representation of this store.
   */
  toJSON(): string[];

  /**
   * @private
   */
  protected _set(entry: T): T;

  /**
   * Adds a new item to this store.
   * @param data
   * @private
   */
  protected _add(data: Dictionary): T;
}

export class User extends Base {
  /**
   * The ID of this user.
   */
  readonly id: string;
  /**
   * The user's avatar hash.
   */
  avatar: string | null;
  /**
   * Whether the user belongs to an OAuth2 application.
   */
  bot: boolean;
  /**
   * The user's 4-digit discord-tag.
   */
  discriminator: string;
  /**
   * The user's email.
   */
  email: string | null;
  /**
   * The flags on this user's account.
   */
  flags: UserFlags;
  /**
   * The public flags on this user's account.
   */
  publicFlags: UserFlags;
  /**
   * The type of Nitro subscription on this user's account.
   */
  premiumType: UserPremiumType;
  /**
   * The user's chosen language option.
   */
  locale: string;
  /**
   * The user's username, not unique across the platform.
   */
  username: string;
  /**
   * Whether the user has two factor enabled on their account.
   */
  mfaEnabled: boolean;
  /**
   * Whether the email on this account has been verified.
   */
  verified: boolean;
  /**
   * Whether the user is an Official Discord System user (part of the urgent message system).
   */
  system: boolean;

  /**
   * Creates a new instance of User.
   * @param client The client.
   * @param data The decoded user data.
   */
  constructor(client: Client, data: APIUser);

  /**
   * The date when this user was created.
   */
  get createdAt(): Date;

  /**
   * The timestamp when this user was created.
   */
  get createdTimestamp(): number;

  /**
   * The tag of this user.
   */
  get tag(): string;

  /**
   * The mention string for this user.
   */
  get mention(): string;

  /**
   * The default avatar url for this user.
   */
  get defaultAvatarUrl(): string;

  /**
   * The URL for this user's avatar.
   * @param options The options for the url.
   */
  avatarURL(options?: ImageURLOptions): string | null;

  /**
   * The display avatar url for this user.
   * @param options The options for the avatar.
   */
  displayAvatarURL(options?: ImageURLOptions): string;

  /**
   * Get the string representation of this user.
   */
  toString(): string;

  /**
   * Updates this user with data from the api.
   * @protected
   */
  protected _patch(data: APIUser): this;
}

export class Guild extends Base {
  /**
   * The ID of this guild.
   */
  readonly id: string;
  /**
   * The shard that this guild operates on.
   */
  readonly shard: InternalShard;
  /**
   * The name of this guild.
   */
  name: string;
  /**
   * The ID of the AFK Voice Channel.
   */
  afkChannelId: string | null;
  /**
   * AFK Timeout in seconds.
   */
  afkTimeout: number | null;
  /**
   * Approximate number of members in this guild.
   */
  approximateMemberCount: number | null;
  /**
   * Approximate number of non-offline members in this guild.
   */
  approximatePresenceCount: number | null;
  /**
   * The hash of the guild banner,
   */
  banner: string | null;
  /**
   * The description of this guild, if the guild is discoverable.
   */
  description: string | null;
  /**
   * The discovery splash hash, only for guilds that are discoverable.
   */
  discoverySplash: string | null;
  /**
   * The explicit content filter config.
   */
  contentFilter: GuildExplicitContentFilter;
  /**
   * Enabled guild features.
   */
  features: GuildFeature[];
  /**
   * Timestamp for when the client joined the guild.
   */
  joinedTimestamp: number | null;
  /**
   * Whether this guild is considered a large guild.
   */
  large: boolean;
  /**
   * The maximum number of members allowed in this guild.
   */
  maxMembers?: number;
  /**
   * The maximum number of presences for this guild.
   */
  maxPresences: number;
  /**
   * The maximum amount of users in a video channel
   */
  maxVideoChannelUsers: number | null;
  /**
   * Total number of members in this guild
   */
  memberCount: number | null;
  /**
   * The ID of the user who owns this guild.
   */
  ownerId: string;
  /**
   * The preferred locale of a guild with the PUBLIC feature, defaults to "en-US".
   */
  preferredLocale: string;
  /**
   * The number of boosts this guild currently has.
   */
  boostCount: number;
  /**
   * The current boost tier of this guild.
   */
  boostTier: GuildPremiumTier;
  /**
   * The ID of the channel where admins/moderators of guilds with the PUBLIC feature will receives notices from Discord.
   */
  updatesChannelId: string | null;
  /**
   * The voice region of this guild.
   */
  region: string;
  /**
   * The ID of the channel where guilds with the PUBLIC feature can display rules and/or guidelines.
   */
  rulesChannelId: string | null;
  /**
   * System channel flags.
   */
  systemChannelFlags: GuildSystemChannelFlags;
  /**
   * The id of the channel where guild notices such as welcome messages and boost events are posted.
   */
  systemChannelId: string | null;
  /**
   * The vanity invite code for this server.
   */
  vanityURLCode: string | null;
  /**
   * Verification level required for this guild.
   */
  verificationLevel: GuildVerificationLevel;
  /**
   * The icon hash.
   */
  icon: string | null;
  /**
   * The welcome screen, only for community servers.
   */
  welcomeScreen?: WelcomeScreen;
  /**
   * Whether this guild is unavailable or not.
   */
  unavailable: boolean;

  /**
   * Creates a new instance of Guild.
   * @param client
   * @param data
   */
  constructor(client: Client, data: APIGuild);

  /**
   * The date when this guild was created.
   */
  get createdAt(): Date;

  /**
   * Timestamp of when this guild was created.
   */
  get createdTimestamp(): number;

  /**
   * The snowflake data.
   */
  get snowflake(): Snowflake;

  /**
   * Updates this guild with data from the api.
   * @protected
   */
  protected _patch(data: APIGuild): this;
}

export class WelcomeScreen {
  /**
   * The guild this welcome screen belongs to.
   */
  readonly guild: Guild;
  /**
   * The description of the server.
   */
  description: string | null;
  /**
   * Configured welcome screen channels.
   */
  welcomeChannels: WelcomeChannel[];

  /**
   * Creates a new instanceof WelcomeScreen.
   * @param guild The guild that this welcome screen belongs to.
   * @param data
   */
  constructor(guild: Guild, data: APIGuildWelcomeScreen);

  /**
   * Updates this instance with data from the api.
   * @protected
   */
  protected _patch(data: APIGuildWelcomeScreen): this;
}

export class WelcomeChannel {
  /**
   * The welcome screen.
   */
  readonly welcomeScreen: WelcomeScreen;
  /**
   * The ID of the channel this welcome channel belongs to.
   */
  channelId: string;
  /**
   * The ID of the emoji used.
   */
  emojiId: string | null;
  /**
   * The name of the emoji used.
   */
  emojiName: string | null;

  /**
   * Creates a new instanceof WelcomeChannel.
   * @param welcomeScreen The welcome screen.
   * @param data The welcome channel data.
   */
  constructor(welcomeScreen: WelcomeScreen, data: APIGuildWelcomeScreenChannel);

  /**
   * The guild this welcome channel belongs to.
   */
  get guild(): Guild;
}

