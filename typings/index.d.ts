// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../discord-api-types
//   ../@neocord/utils
//   ../discord-api-types
//   ../@neocord/gateway
//   ../@neocord/rest
//   ../url
//   ../util
//   ../stream

import type {
  APIAttachment,
  APIBan,
  APIChannel,
  APIChannelMention,
  APIEmbed,
  APIEmbedAuthor,
  APIEmbedField,
  APIEmbedFooter,
  APIEmbedImage,
  APIEmbedProvider,
  APIEmbedThumbnail,
  APIEmbedVideo,
  APIEmoji,
  APIExtendedInvite,
  APIGuild,
  APIGuildMember,
  APIGuildWelcomeScreen,
  APIGuildWelcomeScreenChannel,
  APIMessage,
  APIOverwrite,
  APIRole,
  APIRoleTags,
  APIUser,
  APIVoiceRegion,
  ChannelType,
  EmbedType,
  GatewayActivity,
  GatewayPresenceClientStatus,
  GatewayPresenceUpdate,
  GatewayVoiceState,
  GuildExplicitContentFilter,
  GuildFeature,
  GuildPremiumTier,
  GuildSystemChannelFlags,
  GuildVerificationLevel,
  InviteTargetUserType,
  MessageFlags,
  MessageType,
  OverwriteType,
  PresenceUpdateStatus,
  RESTGetAPIGuildVanityUrlResult,
  UserFlags,
  UserPremiumType
} from "discord-api-types";
import type {
  BitField,
  BitFieldObject,
  Class,
  Collection,
  DeconstructedSnowflake,
  Emitter,
  Extender,
  snowflake
} from "@neocord/utils";
import type { GatewayEvent, ISMOptions, Shard, ShardManager } from "@neocord/gateway";
import type { API, APIOptions, File, ImageURLOptions, RequestData } from "@neocord/rest";
import type { URL } from "url";
import type * as Util from "util";
import type { Readable } from "stream";

declare global {
  interface Object {
    entries<O extends Record<PropertyKey, unknown>, K extends keyof O>(obj: O): ArrayLike<[ K, O[K] ]>;

    keys<O extends Record<PropertyKey, unknown>, K extends keyof O>(obj: O): K[];
  }
}

export class CategoryChannel extends GuildChannel {
  readonly structureType = DiscordStructure.GuildChannel;
  /**
   * The type of channel this is.
   * @type {ChannelType.GUILD_CATEGORY}
   */
  readonly type = ChannelType.GUILD_CATEGORY;

  /**
   * All channels that are a child of this category.
   * @returns {Collection<string, GuildChannel>}
   */
  get children(): Collection<string, GuildChannel>;
}

export abstract class GuildChannel extends Channel {
  /**
   * The guild that this channel belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The permission overwrites that belong to this channel.
   * @type {OverwriteManager}
   */
  overwrites: OverwriteManager;
  /**
   * The name of this channel.
   * @type {string}
   */
  name: string;
  /**
   * The sorting position of this channel.
   * @type {number}
   */
  position: number;
  /**
   * The ID of the parent category.
   * @type {string}
   */
  parentId: string | null;
  /**
   * Whether this channel is deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof GuildChannel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data returned from the api.
   * @param {Guild} [guild] The guild instance.
   */
  constructor(client: Client, data: APIChannel, guild?: Guild);

  /**
   * Get the parent category of this channel.
   * @type {CategoryChannel | null}
   */
  get parent(): CategoryChannel | null;

  /**
   * Deletes this guild channel.
   * @param {string} [reason] The reason for deleting this channel.
   * @returns {Promise<Readonly<this>>}
   */
  delete(reason?: string): Promise<Readonly<this>>;

  /**
   * Modifies this channel.
   * @param {ModifyGuildChannel} data The channel modify options.
   * @param {string} [reason] The reason for updating this channel.
   */
  modify(data: ModifyGuildChannel, reason?: string): Promise<this>;

  /**
   * Updates this guild channel with data from the API.
   * @param {APIChannel} data
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export interface ModifyGuildChannel extends Dictionary {
  name?: string;
  position?: number | null;
  permissionOverwrites?: (PermissionOverwrite | APIOverwrite)[] | null;
  parent?: CategoryChannel | string;
}

export class NewsChannel extends TextChannel {
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_NEWS}
   */
  readonly type = ChannelType.GUILD_NEWS;

  /**
   * Subscribes a channel to cross-post messages from this channel.
   * @param {string | TextChannel} channel The channel to cross-post to.
   * @returns {FollowedChannel} The follow result.
   */
  follow(channel: string | TextChannel): Promise<FollowedChannel>;

  /**
   * Cross-posts a message in this channel.
   * @param {string | Message} message The message to crosspost.
   * @returns {Promise<Message>} The cross-posted message.
   */
  crosspost(message: string | Message): Promise<Message>;
}

export interface FollowedChannel {
  channelId: string;
  webhookId: string;
}

export class StoreChannel extends GuildChannel {
  readonly structureType = DiscordStructure.GuildChannel;
  /**
   * The type of channel.
   * @type {ChannelType.GUILD_STORE}
   */
  readonly type = ChannelType.GUILD_STORE;
}

export class TextChannel extends GuildChannel {
  /**
   * The structure type of this channel.
   * @type {DiscordStructure}
   */
  readonly structureType: DiscordStructure;
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_TEXT}
   */
  readonly type: ChannelType;
  /**
   * The typing helper for this channel.
   * @type {Typing}
   */
  readonly typing: Typing;
  /**
   * The message manager for this channel.
   * @type {MessageManager}
   */
  readonly messages: MessageManager;
  /**
   * The pinned message manager for this channel.
   * @type {PinnedMessageManager}
   */
  readonly pins: PinnedMessageManager;
  /**
   * Amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission ManageMessages or ManageChannel, are unaffected.
   * Or null if there isn't a configured ratelimit.
   * @type {number}
   */
  ratelimit: number | null;
  /**
   * Whether this channel is not safe for work.
   * @type {boolean}
   */
  nsfw: boolean;
  /**
   * The channel topic.
   * @type {string}
   */
  topic: string | null;
  /**
   * The last message that was sent in this channel.
   * @type {string}
   */
  lastMessageId: snowflake | null;
  /**
   * The last message to be pinned in this channel.
   * @type {number | null}
   */
  lastPinTimestamp: number | null;

  /**
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from discord.
   */
  constructor(client: Client, data: APIChannel);

  /**
   * Whether the current user can attach files in this channel.
   * @type {boolean}
   */
  get attachable(): boolean;

  /**
   * If the current user can send messages in this channel.
   * @type {boolean}
   */
  get postable(): boolean;

  /**
   * If the current user can embed links in this channel.
   * @type {boolean}
   */
  get embeddable(): boolean;

  /**
   * If the current user can view this channel.
   * @type {boolean}
   */
  get viewable(): boolean;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  send(builder: Builder | MessageBuilder): Promise<Message[]>;

  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  send(options: MessageOptions): Promise<Message[]>;

  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  send(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Modifies this text channel.
   * @param {ModifyGuildChannel} data The data to modify the channel with.
   * @param {string} [reason] The reason to provide.
   */
  modify(data: ModifyTextChannel, reason?: string): Promise<this>;

  /**
   * Updates this text channel with data from Discord.
   * @param {APIChannel} data
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export interface ModifyTextChannel extends ModifyGuildTextChannel {
  userRatelimit?: number | string | null;
}

export interface ModifyGuildTextChannel extends ModifyGuildChannel {
  type?: ChannelType.GUILD_TEXT | ChannelType.GUILD_NEWS;
  topic?: string | null;
  nsfw?: boolean;
  parent?: string | CategoryChannel;
}

export class VoiceChannel extends GuildChannel {
  readonly structureType = DiscordStructure.GuildChannel;
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_VOICE}
   */
  readonly type = ChannelType.GUILD_VOICE;
  /**
   * The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers).
   * @type {number}
   */
  bitrate: number;
  /**
   * The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit.
   * @type {number}
   */
  userLimit: number;

  /**
   * Whether the current user can delete this voice channel.
   * @type {boolean}
   */
  get deletable(): boolean;
}

export abstract class Channel extends SnowflakeBase {
  /**
   * The ID of this channel.
   * @type {string}
   */
  readonly id: string;
  /**
   * The typeof channel this is.
   * @type {ChannelType}
   */
  abstract readonly type: ChannelType;
  /**
   * Whether this channel has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Channel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from the api.
   */
  constructor(client: Client, data: APIChannel);

  /**
   * The REST api endpoint for this channel.
   * @type {string}
   */
  get endpoint(): string;

  /**
   * Creates a new channel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The channel data from discord.
   * @param {...*} args The arguments to pass.
   */
  static create<T extends Channel>(client: Client, data: APIChannel, ...args: any[]): T | null;

  /**
   * Check whether a channel is in a guild..
   * @param {DiscordChannel} channel The channel to check
   * @returns {boolean} Whether the channel is in a guild or not.
   */
  static isGuildBased(channel: Channel): channel is GuildBasedChannel;

  /**
   * Check whether a channel is textable.
   * @param {DiscordChannel} channel The channel to check
   * @returns {boolean} Whether the channel is textable or not.
   */
  static isTextable(channel: Channel): channel is TextBasedChannel;
}

export type TextBasedChannel = DMChannel | TextChannel | NewsChannel;
export type GuildBasedChannel = TextChannel | NewsChannel | StoreChannel | CategoryChannel | VoiceChannel;
export type DiscordChannel = GuildBasedChannel | DMChannel;

export class DMChannel extends Channel {
  readonly structureType = DiscordStructure.DMChannel;
  /**
   * The type of this channel.
   * @type {ChannelType.DM}
   */
  readonly type = ChannelType.DM;
  /**
   * The recipients of this DM.
   * @type {Array<User>}
   */
  recipients: User[];
  /**
   * Whether this DM channel has been deleted.
   * @type {boolean}
   */
  deleted: boolean;
  /**
   * The typing helper for this channel.
   * @type {Typing}
   */
  readonly typing: Typing;
  /**
   * The message manager for this channel.
   * @type {MessageManager}
   */
  readonly messages: MessageManager;
  /**
   * The pinned message manager for this channel.
   * @type {PinnedMessageManager}
   */
  readonly pins: PinnedMessageManager;
  /**
   * The last message that was sent in this channel.
   * @type {string}
   */
  lastMessageId: snowflake | null;
  /**
   * The last message to be pinned in this channel.
   * @type {number | null}
   */
  lastPinTimestamp: number | null;

  /**
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from discord.
   */
  constructor(client: Client, data: APIChannel);

  /**
   * Whether the current user can attach files in this channel.
   * @type {boolean}
   */
  get attachable(): boolean;

  /**
   * If the current user can send messages in this channel.
   * @type {boolean}
   */
  get postable(): boolean;

  /**
   * If the current user can embed links in this channel.
   * @type {boolean}
   */
  get embeddable(): boolean;

  /**
   * If the current user can view this channel.
   * @type {boolean}
   */
  get viewable(): boolean;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  send(builder: Builder | MessageBuilder): Promise<Message[]>;
  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  send(options: MessageOptions): Promise<Message[]>;
  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  send(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Closes this DM.
   * @returns {DMChannel}
   */
  close(): Promise<DMChannel>;

  /**
   * Updates this dm channel with data from discord.
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export class Typing {
  /**
   * The client instance.
   * @type {Client}
   */
  readonly client: Client;
  /**
   * The channel instance.
   * @type {TextBasedChannel}
   */
  readonly channel: TextBasedChannel;

  /**
   * Creates a new instanceof Typing.
   * @param {TextBasedChannel} channel The channel instance.
   */
  constructor(channel: TextBasedChannel);

  /**
   * Increases the interval count and starts typing if not already.
   * @param {number} [count=1] How much to increase the interval count.
   * @returns {Promise<Typing>} This instanceof Typing.
   */
  start(count?: number): Promise<this>;

  /**
   * Decreases the interval count and stops typing if the count is 0 or lower.
   * @param {number} [count=1] How much to decrease the interval count.
   * @returns {Typing} This instanceof Typing.
   */
  stop(count?: number): this;

  /**
   * Forces the typing count to 0 and stops typing.
   * @returns {Typing} This instanceof Typing.
   */
  forceStop(): this;

  /**
   * Starts the typing interval if not already started.
   * @returns {Promise<void>} Nothing...
   */
  protected _start(): Promise<void>;

  /**
   * Stops the typing interval if not already stopped.
   * @returns {void} Nothing...
   */
  protected _stop(): void;

  /**
   * Triggers the typing indicator in the channel.
   * @returns {Promise<void>} Nothing...
   */
  protected _send(): Promise<void>;
}

export class BaseGuildEmoji extends Emoji {
  /**
   * The ID of this emoji.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild that this emoji belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * Whether this emoji must be wrapped in colons
   * @type {?boolean}
   */
  requireColons?: boolean;
  /**
   * Whether this emoji is managed.
   * @type {?boolean}
   */
  managed?: boolean;
  /**
   * Whether this emoji can be used, may be false due to loss of Server Boosts
   * @type {?boolean}
   */
  available?: boolean;
  /**
   * Roles this emoji is whitelisted to.
   * @type {?Array<string>}
   * @protected
   */
  protected _roles?: string[];

  /**
   *
   * @param {Client} client
   * @param {APIEmoji} data
   * @param {Guild} guild
   */
  constructor(client: Client, data: APIEmoji, guild: Guild);

  /**
   * Updates this role with data from discord.
   * @protected
   */
  protected _patch(data: APIEmoji): this;
}

export class GuildEmoji extends BaseGuildEmoji {
  /**
   * The member that created this guild emoji.
   * @type {Member}
   */
  author?: Member;

  /**
   * Roles this emoji is whitelisted to.
   * @type {Collection<string, Role>}
   */
  get roles(): Collection<string, Role>;

  /**
   * Updates this guild emoji with data from discord.
   * @protected
   */
  protected _patch(data: APIEmoji): this;
}

export class GuildPreviewEmoji extends BaseGuildEmoji {
}

export class WelcomeChannel {
  /**
   * The welcome screen.
   * @type {WelcomeScreen}
   */
  readonly welcomeScreen: WelcomeScreen;
  /**
   * The ID of the channel this welcome channel belongs to.
   * @type {string}
   */
  channelId: string;
  /**
   * The ID of the emoji used.
   * @type {string | null}
   */
  emojiId: string | null;
  /**
   * The name of the emoji used.
   * @type {string | null}
   */
  emojiName: string | null;

  /**
   * Creates a new instanceof WelcomeChannel.
   * @param {WelcomeScreen} welcomeScreen The welcome screen.
   * @param {APIGuildWelcomeScreenChannel} data The welcome channel data.
   */
  constructor(welcomeScreen: WelcomeScreen, data: APIGuildWelcomeScreenChannel);

  /**
   * The guild this welcome channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * The channel instance.
   * @type {TextChannel}
   */
  get channel(): TextBasedChannel;
}

export class WelcomeScreen {
  /**
   * The guild this welcome screen belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The description of the server.
   * @type {string | null}
   */
  description: string | null;
  /**
   * Configured welcome screen channels.
   * @type {Collection<string, WelcomeChannel>}
   */
  welcomeChannels: Collection<string, WelcomeChannel>;

  /**
   * Creates a new instanceof WelcomeScreen.
   * @param {Guild} guild The guild that this welcome screen belongs to.
   * @param {APIGuildWelcomeScreen} data The welcome screen data from the api.
   */
  constructor(guild: Guild, data: APIGuildWelcomeScreen);

  /**
   * Updates this instance with data from the api.
   * @param {APIGuildWelcomeScreen} data
   * @protected
   */
  protected _patch(data: APIGuildWelcomeScreen): this;
}

export class Ban extends SnowflakeBase {
  readonly structureType = DiscordStructure.Ban;
  /**
   * ID of the banned user.
   * @type {string}
   */
  readonly id: string;
  /**
   * The reason for the ban.
   * @type {string | null}
   */
  readonly reason: string | null;
  /**
   * The guild the ban belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * Whether this ban has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Ban.
   * @param {Guild} guild The guild instance.
   * @param {APIBan} data The ban data from discord.
   */
  constructor(guild: Guild, data: APIBan);

  /**
   * Deletes this ban. (unban's the user)
   * @param {string} [reason] Reason for unbanning the user.
   * @returns {Ban}
   */
  delete(reason: string): Promise<this>;
}

export class Guild extends Base {
  readonly structureType = DiscordStructure.Guild;
  /**
   * The ID of this guild.
   * @type {string}
   */
  readonly id: string;
  /**
   * The shard that this guild operates on.
   * @type {Shard}
   */
  readonly shard: Shard;
  /**
   * All cached roles for this guild.
   * @type {RoleManager}
   */
  readonly roles: RoleManager;
  /**
   * All presences for this guild.
   * @type {PresenceManager}
   */
  readonly presences: PresenceManager;
  /**
   * All cached voice states for this guild.
   * @type {VoiceStateManager}
   */
  readonly voiceStates: VoiceStateManager;
  /**
   * All cached channels for this guild.
   * @type {GuildChannelManager}
   */
  readonly channels: GuildChannelManager;
  /**
   * All cached members for this guild.
   * @type {MemberManager}
   */
  readonly members: MemberManager;
  /**
   * All cached bans for this guild.
   * @type {BanManager}
   */
  readonly bans: BanManager;
  /**
   * Whether this guild has been deleted from the cache.
   * @type {boolean}
   */
  deleted: boolean;
  /**
   * The name of this guild.
   * @type {string}
   */
  name: string;
  /**
   * The ID of the AFK Voice Channel.
   * @type {string | null}
   */
  afkChannelId: string | null;
  /**
   * AFK Timeout in seconds.
   * @type {number | null}
   */
  afkTimeout: number | null;
  /**
   * Approximate number of members in this guild.
   * @type {number | null}
   */
  approximateMemberCount: number | null;
  /**
   * Approximate number of non-offline members in this guild.
   * @type {number | null}
   */
  approximatePresenceCount: number | null;
  /**
   * The hash of the guild banner,
   * @type {string | null}
   */
  banner: string | null;
  /**
   * The description of this guild, if the guild is discoverable.
   * @type {string | null}
   */
  description: string | null;
  /**
   * The discovery splash hash, only for guilds that are discoverable.
   * @type {string | null}
   */
  discoverySplash: string | null;
  /**
   * The explicit content filter config.
   * @type {GuildExplicitContentFilter}
   */
  contentFilter: GuildExplicitContentFilter;
  /**
   * Enabled guild features.
   * @type {Array<GuildFeature>}
   */
  features: GuildFeature[];
  /**
   * Timestamp for when the client joined the guild.
   * @type {number | null}
   */
  joinedTimestamp: number | null;
  /**
   * Whether this guild is considered a large guild.
   * @type {boolean}
   */
  large: boolean;
  /**
   * The maximum number of members allowed in this guild.
   * @type {number}
   */
  maxMembers?: number;
  /**
   * The maximum number of presences for this guild.
   * @type {number}
   */
  maxPresences?: number;
  /**
   * The maximum amount of users in a video channel
   * @type {number | null}
   */
  maxVideoChannelUsers: number | null;
  /**
   * Total number of members in this guild
   * @type {number | null}
   */
  memberCount: number | null;
  /**
   * The ID of the user who owns this guild.
   * @type {string}
   */
  ownerId: string;
  /**
   * The preferred locale of a guild with the PUBLIC feature, defaults to "en-US".
   * @type {string}
   */
  preferredLocale: string;
  /**
   * The number of boosts this guild currently has.
   * @type {number}
   */
  boostCount: number;
  /**
   * The current boost tier of this guild.
   * @type {GuildPremiumTier}
   */
  boostTier: GuildPremiumTier;
  /**
   * The ID of the channel where admins/moderators of guilds with the PUBLIC feature will receives notices from Discord.
   * @type {string | null}
   */
  updatesChannelId: string | null;
  /**
   * The voice region of this guild.
   * @type {string}
   */
  region: string;
  /**
   * The ID of the channel where guilds with the PUBLIC feature can display rules and/or guidelines.
   * @type {string | null}
   */
  rulesChannelId: string | null;
  /**
   * System channel flags.
   * @type {GuildSystemChannelFlags}
   */
  systemChannelFlags: GuildSystemChannelFlags;
  /**
   * The id of the channel where guild notices such as welcome messages and boost events are posted.
   * @type {string | null}
   */
  systemChannelId: string | null;
  /**
   * The vanity invite code for this server.
   * @type {string | null}
   */
  vanityURLCode: string | null;
  /**
   * Verification level required for this guild.
   * @type {GuildVerificationLevel}
   */
  verificationLevel: GuildVerificationLevel;
  /**
   * The icon hash.
   * @type {string | null}
   */
  icon: string | null;
  /**
   * The welcome screen, only for community servers.
   * @type {WelcomeScreen}
   */
  welcomeScreen?: WelcomeScreen;
  /**
   * Whether this guild is unavailable or not.
   * @type {boolean}
   */
  unavailable: boolean;

  /**
   * Creates a new instance of Guild.
   * @param {Client} client
   * @param {APIGuild} data
   */
  constructor(client: Client, data: APIGuild);

  /**
   * The client as a member of this guild.
   * @type {Member}
   */
  get me(): Member;

  /**
   * Get the icon URL of this guild.
   * @param {ImageURLOptions} [options] The URL options.
   * @returns {?string} Returns the URL of the guild icon, if any.
   */
  iconURL(options?: ImageURLOptions): string | null;

  /**
   * Make the current user leave this guild.
   * @returns {Promise<Guild>} This guild.
   */
  leave(): Promise<Readonly<Guild>>;

  /**
   * The list of voice regions for this guild.
   * @returns {Promise<Array<APIVoiceRegion>>} The voice regions for this guild.
   */
  fetchRegions(): Promise<APIVoiceRegion[]>;

  /**
   * Fetches this guilds vanity url if it's enabled.
   * @returns {Promise<RESTGetAPIGuildVanityUrlResult>} This guilds vanity url.
   */
  fetchVanityUrl(): Promise<RESTGetAPIGuildVanityUrlResult>;

  /**
   * Deletes this guild. Current user must be the owner.
   * @returns {Promise<Readonly<Guild>>} This guild.
   */
  delete(): Promise<Readonly<Guild>>;

  /**
   * The string representation of this guild.
   * @returns {string} The name of the guild.
   */
  toString(): string;

  /**
   * Updates this guild with data from the api.
   * @protected
   */
  protected _patch(data: APIGuild): this;
}

export class Member extends Base {
  readonly structureType = DiscordStructure.Member;
  /**
   * The ID of this member.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild this member belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The roles that belong to this member.
   * @type {MemberRoleManager}
   */
  readonly roles: MemberRoleManager;
  /**
   * This users guild nickname.
   * @type {string | null}
   */
  nickname: string | null;
  /**
   * When the user joined the guild.
   * @type {number}
   */
  joinedTimestamp: number;
  /**
   * When the user started boosting the guild.
   * @type {number | null}
   */
  boostedTimestamp: number | null;
  /**
   * Whether the user is muted in voice channels.
   * @type {boolean}
   */
  deaf: boolean;
  /**
   * Whether the user is deafened in voice channels.
   * @type {boolean}
   */
  mute: boolean;
  /**
   * Whether this member has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Member
   * @param {Guild} guild
   * @param {APIGuildMember} data
   */
  constructor(guild: Guild, data: APIGuildMember);

  /**
   * The presence of this member.
   * @type {Presence | null}
   */
  get presence(): Presence | null;

  /**
   * The user that this guild member represents.
   * @type {User}
   */
  get user(): User;

  /**
   * The calculated permissions from the member's roles.
   * @type {Permissions}
   */
  get permissions(): Permissions;

  /**
   * The displayed name for this guild member.
   * @type {string}
   */
  get displayName(): string;

  /**
   * The {@link VoiceState voice state} of this member.
   * @type {VoiceState | null}
   */
  get voice(): VoiceState | null;

  /**
   * The mention string for this member.
   * @type {string}
   */
  get mention(): string;

  /**
   * The string representation of this member.
   * @type {string}
   */
  toString(): string;

  /**
   * Checks permissions for this member in a given channel.
   * @param {GuildChannel} channel The guild channel.
   * @param {boolean} [guildScope]
   * @type {Readonly<Permissions>}
   */
  permissionsIn(channel: GuildChannel, guildScope?: boolean): Readonly<Permissions>;

  /**
   * Kicks this member from the {@link Guild guild}.
   * @param {string} [reason] The audit-log reason.
   * @returns {Member}
   */
  kick(reason?: string): Promise<Readonly<Member>>;

  /**
   * Bans this member from the {@link Guild guild}.
   * @param {BanOptions} [options] The options for the {@link Ban ban}.
   * @returns {Member}
   */
  ban(options?: BanOptions): Promise<Readonly<Member>>;

  /**
   * Updates this guild member from the discord gateway/api.
   * @param {APIGuildMember} data
   * @protected
   */
  protected _patch(data: APIGuildMember): this;
}

export class PermissionOverwrite extends Base {
  readonly structureType = DiscordStructure.Overwrite;
  /**
   * The role or user ID.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild channel that this permission overwrite belongs to.
   * @type {GuildChannel}
   */
  readonly channel: GuildChannel;
  /**
   * Either "role" or "member"
   * @type {OverwriteType}
   */
  readonly type: OverwriteType;
  /**
   * The permissions this overwrite denies.
   * @type {Readonly<Permissions>}
   */
  deny: Readonly<Permissions>;
  /**
   * The permissions this overwrite allows.
   * @type {Readonly<Permissions>}
   */
  allow: Readonly<Permissions>;
  /**
   * Whether this permission overwrite has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof PermissionOverwrite.
   * @param {Client} client The client instance.
   * @param {APIOverwrite} data The overwrite data from discord.
   * @param {GuildChannel} channel The guild channel that this permission overwrite belongs to.
   */
  constructor(client: Client, data: APIOverwrite, channel: GuildChannel);

  /**
   * Resolves an overwrite into an object.
   * @param {PermissionOverwrite | APIOverwrite} overwrite The permission overwrite instance.
   * @param {Guild} guild The guild instance.
   * @returns {APIOverwrite} The resolved overwrite.
   */
  static resolve(overwrite: PermissionOverwrite | APIOverwrite, guild: Guild): APIOverwrite;

  /**
   * Update this permission overwrite
   * @param {Record<Permission, boolean | null>} options The options for the update.
   * @param {string} [reason] Reason for creating/editing this overwrite.
   * @returns {PermissionOverwrite}
   */
  update(options: Record<Permission, boolean | null>, reason?: string): Promise<PermissionOverwrite>;

  /**
   * The JSON representation of this overwrite.
   * @returns {APIOverwrite}
   */
  toJSON(): APIOverwrite;

  /**
   * Updates this permission overwrite with data from discord.
   * @protected
   */
  protected _patch(data: APIOverwrite): this;
}

export class Presence extends Base {
  readonly structureType = DiscordStructure.Presence;
  /**
   * The id of the member this presence corresponds to.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild instance.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The member's status.
   * @type {PresenceUpdateStatus}
   */
  status: PresenceUpdateStatus;
  /**
   * The member's platform-dependant status.
   * @type {GatewayPresenceClientStatus}
   */
  clientStatus: GatewayPresenceClientStatus;
  /**
   * The member's current activities.
   * @type {Array<GatewayActivity>}
   */
  activities: GatewayActivity[];

  /**
   * Creates a new instanceof Presence.
   * @param {Client} client The client instance.
   * @param {GatewayPresenceUpdate} data The presence update.
   * @param {Guild} [guild] The guild instance.
   */
  constructor(client: Client, data: GatewayPresenceUpdate, guild?: Guild);

  /**
   * The guild member that this presence belongs to.
   * @type {Member}
   */
  get member(): Member;

  /**
   * Updates this presence with from the gateway.
   * @param {GatewayPresenceUpdate} data
   * @protected
   */
  protected _patch(data: GatewayPresenceUpdate): this;
}

/**
 * Represents a Discord Role.
 * @extends {SnowflakeBase}
 */
export class Role extends SnowflakeBase {
  readonly structureType = DiscordStructure.Role;
  /**
   * The ID of this role.
   * @type {string}
   */
  readonly id: string;
  /**
   * The {@link Guild guild} this role belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The color that this role has.
   * @type {number}
   */
  color: number;
  /**
   * If this role is pinned in the user listing
   * @type {boolean}
   */
  hoisted: boolean;
  /**
   * Whether this role is managed by an integration
   * @type {boolean}
   */
  managed: boolean;
  /**
   * Whether this role is mentionable
   * @type {boolean}
   */
  mentionable: boolean;
  /**
   * The name of this role.
   * @type {string}
   */
  name: string;
  /**
   * The permissions of this role.
   * @type {Permissions}
   */
  permissions: Permissions;
  /**
   * The position of this role
   * @type {number}
   */
  position: number;
  /**
   * Tags for this role.
   * @type {APIRoleTags}
   */
  tags: APIRoleTags | null;
  /**
   * Whether this role has been deleted or not.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Role.
   * @param {Client} client The client instance.
   * @param {APIRole} data Data sent from the Discord API.
   * @param {Guild} guild The guild that this role belongs to.
   */
  constructor(client: Client, data: APIRole, guild: Guild);

  /**
   * Whether or not this role is @everyone
   * @type {boolean}
   */
  get everyone(): boolean;

  /**
   * All of the guild members that have this role.
   * @type {Collection<string, Member>}
   */
  get members(): Collection<string, Member>;

  /**
   * The mention string of this role.
   * @type {string}
   */
  get mention(): string;

  /**
   * The string representation of this role.
   * @type {string}
   */
  toString(): string;

  /**
   * Deletes the role from the guild.
   * @param {string} [reason]
   */
  delete(reason?: string): Promise<this>;

  /**
   * Modifies this guild role.
   * @param {ModifyRoleData} data The data to update this role with.
   * @param {string} [reason]
   */
  modify(data: ModifyRoleData, reason?: string): Promise<this>;

  /**
   * Add this role to a guild member.
   * @param {MemberResolvable} target The target member.
   * @param {string} [reason] The reason for adding the role.
   */
  addTo(target: MemberResolvable, reason?: string): Promise<this>;

  /**
   * Remove this role to a guild member.
   * @param {MemberResolvable} target The target member.
   * @param {string} [reason] The reason for removing the role.
   */
  removeFrom(target: MemberResolvable, reason?: string): Promise<this>;

  /**
   * Checks permissions for this member in a given channel.
   * @param {GuildChannel} channel The channel to check permissions in.
   * @param {boolean} [guildScope] Whether to take into account guild scoped permissions, or just overwrites.
   * @returns {Permissions}
   */
  permissionsIn(channel: GuildChannel, guildScope?: boolean): Readonly<Permissions>;

  /**
   * Updates this role with data from the api.
   * @protected
   */
  protected _patch(data: APIRole): this;
}

/**
 * @interface
 */
export interface ModifyRoleData {
  /**
   * Name of the role.
   */
  name?: string | null;
  /**
   * Permissions to give this role.
   */
  permissions?: PermissionResolvable | null;
  /**
   * RGB color value or hex code.
   */
  color?: number | string | null;
  /**
   * Whether the role should be displayed separately in the sidebar.
   */
  hoist?: boolean | null;
  /**
   * Whether the role should be mentionable.
   */
  mentionable?: boolean | null;
}

export class VoiceState extends Base {
  readonly structureType = DiscordStructure.VoiceState;
  /**
   * The ID of the user the voice state is for.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild this voice state is apart of.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * ID of the channel the user is in.
   * @type {string | null}
   */
  channelId: string | null;
  /**
   * The voice state's session id.
   * @type {string}
   */
  sessionId: string;
  /**
   * Whether this user is deafened by the server.
   * @type {boolean}
   */
  deafened: boolean;
  /**
   * Whether this user is muted by the server.
   * @type {boolean}
   */
  muted: boolean;
  /**
   * Whether this user is locally deafened.
   * @type {boolean}
   */
  selfDeafened: boolean;
  /**
   * Whether this user is locally muted.
   * @type {boolean}
   */
  selfMuted: boolean;
  /**
   * Whether this user is streaming using "Go Live"
   * @type {boolean}
   */
  selfStream: boolean;
  /**
   * Whether this user's camera is enabled.
   * @type {boolean}
   */
  selfVideo: boolean;
  /**
   * Whether this user is muted by the current user.
   * @type {boolean}
   */
  suppressed: boolean;

  /**
   * Creates a new instanceof VoiceState.
   * @param {Client} client The client instance.
   * @param {GatewayVoiceState} data The voice state data.
   * @param {Guild} guild The guild.
   */
  constructor(client: Client, data: GatewayVoiceState, guild: Guild);

  /**
   * The channel that the user is in.
   * @type {VoiceChannel | null}
   */
  get channel(): VoiceChannel | null;

  /**
   * The member this voice state belongs to.
   * @type {Member}
   */
  get member(): Member;

  /**
   * Updates this voice state with data from the discord gateway/api.
   * @protected
   */
  protected _patch(data: GatewayVoiceState): this;
}

export class Message extends SnowflakeBase {
  readonly structureType = DiscordStructure.Message;
  /**
   * The ID of this message.
   * @type {string}
   */
  readonly id: string;
  /**
   * The author of this message.
   * @type {User}
   */
  readonly author: User;
  /**
   * The guild member that sent this message.
   * @type {Member | null}
   */
  readonly member: Member | null;
  /**
   * The guild that this message was sent in.
   * @type {Guild | null}
   */
  readonly guild: Guild | null;
  /**
   * The channel that this message was sent.
   * @type {TextBasedChannel}
   */
  readonly channel: TextBasedChannel;
  /**
   * Any attached files
   * @type {Collection<string, MessageAttachment>}
   */
  readonly attachments: Collection<string, MessageAttachment>;
  /**
   * The mentions in this message.
   * @type {MessageMentions}
   */
  mentions: MessageMentions;
  /**
   * Whether or not this message was TTS.
   * @type {boolean}
   */
  tts: boolean;
  /**
   * Used for validating whether a message was sent.
   * @type {string | number | null}
   */
  nonce: string | number | null;
  /**
   * The current content of this message.
   * @type {string}
   */
  content: string;
  /**
   * The previous content of this message, always null unless editedTimestamp isn't null.
   * @type {string | null}
   */
  previousContent: string | null;
  /**
   * The timestamp of when this message was edited, or null if it hasn't been edited.
   * @type {number | null}
   */
  editedTimestamp: number | null;
  /**
   * Whether this message is pinned.
   * @type {boolean}
   */
  pinned: boolean;
  /**
   * Embeds that were sent along with this message.
   * @type {Array<Embed>}
   */
  embeds: Embed[];
  /**
   * The type of message.
   * @type {MessageType}
   */
  type: MessageType;
  /**
   * The flags.
   * @type {MessageFlags}
   */
  flags: MessageFlags;
  /**
   * Whether this message has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instance of Message.
   * @param {Client} client The client instance.
   * @param {APIMessage} data The decoded message object.
   * @param {Guild} guild The guild instance.
   */
  constructor(client: Client, data: APIMessage, guild?: Guild);

  /**
   * The url to jump to this message.
   * @type {string}
   */
  get url(): string;

  /**
   * The date in which this message was edited.
   * @type {Date}
   */
  get editedAt(): Date | null;

  /**
   * Deletes this message from the channel.
   * @param {MessageDeleteOptions} [options] Options for deleting this message.
   * @returns {Message}
   */
  delete(options?: MessageDeleteOptions): Promise<this>;

  /**
   * Pins this message to the channel.
   * @param reason
   */
  pin(reason?: string): Promise<Message>;

  /**
   * Crosspost a message in a news channel to following channels.
   * @returns {Message}
   */
  crosspost(): Promise<Message>;

  /**
   * Edits this message.
   * @param {MessageEditOptions} options The options to use for editing this message.
   */
  edit(options: MessageEditOptions): Promise<Message>;

  suppressEmbeds(suppress?: boolean): Promise<Message>;

  /**
   * Patches this message with data from the api.
   * @protected
   */
  protected _patch(data: APIMessage): this;
}

export type MessageEditData = string | Embed | MessageEditOptions;

export class MessageAttachment {
  /**
   * The image.
   * @type {ImageResolvable}
   */
  attachment: ImageResolvable;
  /**
   * The name of this attachment.
   * @type {string | null}
   */
  name: string | null;
  /**
   * Attachment id.
   * @type {string}
   */
  id: string;
  /**
   * Size of file in bytes.
   * @type {number}
   */
  size: number;
  /**
   * Source url of file.
   * @type {string}
   */
  url: string;
  /**
   * The proxy url of file.
   * @type {string}
   */
  proxyUrl: string;
  /**
   * Height of file (if image).
   * @type {number | null}
   */
  height: number | null;
  /**
   * Width of file (if image).
   * @type {number | null}
   */
  width: number | null;

  /**
   * @param {ImageResolvable} attachment
   * @param {string} [name=null]
   * @param {APIAttachment} data
   */
  constructor(attachment: ImageResolvable, name: string | null, data: APIAttachment);

  /**
   * Whether or not this attachment has been marked as a spoiler.
   * @type {boolean}
   */
  get spoiler(): boolean;

  /**
   * Set the file of this message attachment
   * @param {ImageResolvable} file The file.
   */
  setFile(file: ImageResolvable): MessageAttachment;

  /**
   * Set the name of this message attachment.
   * @param {string} name The new name of this attachment.
   */
  setName(name: string): MessageAttachment;

  /**
   * Updates this message attachment with data from discord.
   * @protected
   */
  protected _patch(data: APIAttachment): this;
}

export class MessageMentions {
  /**
   * The {@link Message} these mentions belong to.
   * @type {Message}
   */
  readonly message: Message;
  /**
   * Any {@link User users} that mentioned.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, User>}
   */
  users: Collection<string, User>;
  /**
   * Any {@link Role roles} that were mentioned.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, Role>}
   */
  roles: Collection<string, Role>;
  /**
   * A collection of crossposted channels.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, CrosspostedChannel>}
   */
  crosspostedChannels: Collection<string, CrosspostedChannel>;
  /**
   * Whether `@everyone` or `@here` were mentioned
   * @type {boolean}
   */
  everyone: boolean;

  /**
   * @param {Message} message
   * @param {MentionedUser[]} users
   * @param {boolean} everyone
   * @param {string[]} roles
   * @param {APIChannelMention} crossposted
   */
  constructor(message: Message, users: MentionedUser[], everyone: boolean, roles: string[], crossposted?: APIChannelMention[]);

  /**
   * Any {@link Member members} that were mentioned.
   * @type {Collection<string, Member>}
   */
  get members(): Collection<string, Member>;

  /**
   * Any {@link GuildChannel channels} that were mentioned.
   * @type {Collection<string, GuildChannel>}
   */
  get channels(): Collection<string, GuildChannel>;
}

export type MentionedUser = APIUser & {
  member?: Omit<APIGuildMember, "user">;
};

export interface CrosspostedChannel {
  /**
   * The ID of the mentioned channel.
   */
  channelId: string;
  /**
   * The type of of the channel.
   */
  type: ChannelType;
  /**
   * The name of the channel.
   */
  name: string;
  /**
   * The ID of the guild that has the channel.
   */
  guildId: string;
}

export class ClientUser extends User {
  /**
   * Set the username of the current user.
   * @param {string} username The new username.
   */
  setUsername(username: string): Promise<this>;

  /**
   * Update the current users avatar.
   * @param {ImageResolvable | null} avatar The avatar to update the current one with.
   */
  setAvatar(avatar: ImageResolvable | null): Promise<this>;

  /**
   * Updates the current user.
   * @param {ClientUserUpdate} data The new username or avatar to update the current user with.
   */
  update(data?: ClientUserUpdate): Promise<this>;
}

export interface ClientUserUpdate {
  username?: string;
  avatar?: ImageResolvable | null;
}

export class Embed implements APIEmbed {
  /**
   * The embed video
   * @type {APIEmbedVideo}
   */
  readonly video: APIEmbedVideo;
  /**
   * The embed provider.
   * @type {APIEmbedProvider}
   */
  readonly provider: APIEmbedProvider;
  /**
   * The type of embed.
   * @type {EmbedType}
   */
  readonly type: EmbedType;
  /**
   * The title of this embed.
   * @type {string}
   */
  title?: string;
  /**
   * The description of this embed.
   * @type {string}
   */
  description?: string;
  /**
   * The URL of this embed.
   * @type {string}
   */
  url?: string;
  /**
   * The embed timestamp.
   * @type {string}
   */
  timestamp?: string;
  /**
   * The color of this embed.
   * @type {string}
   */
  color?: number;
  /**
   * The embed footer.
   * @type {APIEmbedFooter}
   */
  footer?: APIEmbedFooter;
  /**
   * The embed image.
   * @type {APIEmbedImage}
   */
  image: APIEmbedImage;
  /**
   * The embed thumbnail.
   * @type {APIEmbedThumbnail}
   */
  thumbnail: APIEmbedThumbnail;
  /**
   * The embed author
   * @type {APIEmbedAuthor}
   */
  author: APIEmbedAuthor;
  /**
   * The fields in this embed.
   * @type {Array<APIEmbedField>}
   */
  fields: APIEmbedField[];

  /**
   * Creates a new Embed instance.
   * @param {Embed | APIEmbed} base
   */
  constructor(base?: Embed | APIEmbed);

  /**
   * The embed color as a hex code.
   * @type {string}
   */
  get hex(): string | null;

  /**
   * The accumulated length for the title, description, fields and footer text.
   * @type {number}
   */
  get length(): number;

  /**
   * Set the thumbnail of this embed.
   * @param {string | URL} url The image url.
   * @param {ImageOptions} [options={}] The options for the image.
   */
  setThumbnail(url: StringResolvable | URL, options?: ImageOptions): this;

  /**
   * Adds a new field to this embed.
   * @param {StringResolvable} name The name of the field.
   * @param {StringResolvable | StringResolvable[]} value The field value.
   * @param {boolean} [inline=false] Whether this field is inline with others.
   */
  addField(name: StringResolvable, value: StringResolvable | StringResolvable[], inline?: boolean): Embed;

  /**
   * Adds a new blank field.
   * @param {boolean} [inline=true] Whether this field should be inline with other fields.
   */
  addBlankField(inline?: boolean): Embed;

  /**
   * Set the title of this embed.
   * @param {string} text The title text.
   */
  setTitle(text: StringResolvable): Embed;

  /**
   * Set the color of this embed.
   * @param {ColorResolvable} color The color of this embed.
   */
  setColor(color: ColorResolvable): this;

  /**
   * Set the author of this embed.
   * @param {string} name The author name.
   * @param {AuthorOptions} [opts={}] The author options.
   */
  setAuthor(name: StringResolvable, opts?: AuthorOptions): this;

  /**
   * Set the embed timestamp.
   * @param {number |Date} date The timestamp.
   */
  setTimestamp(date?: number | Date): Embed;

  /**
   * Set the embed footer.
   * @param {string} text Footer text
   * @param {string | URL} icon The URL of footer icon (only supports http(s) and attachments)
   */
  setFooter(text: StringResolvable, icon?: StringResolvable | URL): Embed;

  /**
   * Set the image of this embed.
   * @param {string | URL} url Source URL of image (only supports http(s) and attachments)
   * @param {ImageOptions} [options={}] Options for the image.
   */
  setImage(url: string | URL, options?: ImageOptions): Embed;

  /**
   * Set the description of this embed.
   * @param {string} text The description content.
   */
  setDescription(text: StringResolvable | StringResolvable[]): Embed;
}

export interface StringResolvable {
  toString(): string;
}

export interface AuthorOptions {
  url?: StringResolvable | URL;
  icon?: StringResolvable | URL;
}

export interface ImageOptions {
  height?: number;
  width?: number;
}

export abstract class Emoji extends Base {
  readonly structureType = DiscordStructure.Emoji;
  /**
   * The ID of this emoji.
   * @type {string}
   */
  readonly id: string | null;
  /**
   * The name of this emoji.
   * @type {string}
   */
  name: string;
  /**
   * Whether or not this emoji is animated.
   * @type {boolean}
   */
  animated: boolean;
  /**
   * Whether this emoji has been deleted or not.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * @param {Client} client
   * @param {APIEmoji} data
   */
  constructor(client: Client, data: APIEmoji);

  /**
   * The identifier for this emoji, used for message reactions.
   * @type {string}
   */
  get identifier(): string;

  /**
   * The URL to this emoji. Only if it's a custom emoji.
   * @type {?string}
   */
  get url(): string | null;

  /**
   * The date when this object was created.
   * @type {Date}
   */
  get createdAt(): Date | null;

  /**
   * The time when this object was created.
   * @type {number}
   */
  get createdTimestamp(): number | null;

  /**
   * The string representation of this emoji.
   * @returns {string}
   */
  toString(): string;
}

export class Invite extends Base {
  readonly structureType = DiscordStructure.Invite;
  /**
   * The "ID" of this invite. (the code of the invite)
   * @type {string}
   */
  readonly id: string;
  /**
   * The channel this invite belongs to.
   * @type {Channel}
   */
  readonly channel: Channel;
  /**
   * The guild the channel belongs to. If the channel is in a guild.
   * @type {Guild | null}
   */
  readonly guild: Guild | null;
  /**
   * Duration (in seconds) after which the invite expires
   * @type {number | null}
   */
  maxAge: number | null;
  /**
   * Max number of times this invite can be used
   * @type {number | null}
   */
  maxUses: number | null;
  /**
   * Whether this invite only grants temporary membership
   * @type {boolean | null}
   */
  temporary: boolean;
  /**
   * When this invite was created.
   * @type {number | null}
   */
  createdTimestamp: number | null;
  /**
   * Number of times this invite has been used.
   * @type {number}
   */
  uses: number;
  /**
   * Approximate count of total members
   * @type {number | null}
   */
  approximateMemberCount: number | null;
  /**
   * Approximate count of online members (only present when target_user is set)
   * @type {number | null}
   */
  approximatePresenceCount: number | null;
  /**
   * The user who created the invite
   * @type {User | null}
   */
  inviter: User | null;
  /**
   * The target user for this invite
   * @type {User | null}
   */
  targetUser: User | null;
  /**
   * The type of user target for this invite
   * @type {InviteTargetUserType | null}
   */
  targetUserType: InviteTargetUserType | null;

  /**
   * Creates a new instanceof Invite.
   * @param {Channel} channel The channel this invite belongs to.
   * @param {APIExtendedInvite} data The data returned from the API.
   * @param {Guild} [guild]
   */
  constructor(channel: Channel, data: APIExtendedInvite, guild?: Guild);

  /**
   * The invite code.
   * @type {string}
   */
  get code(): string;

  protected _patch(data: APIExtendedInvite): this;
}

export class User extends SnowflakeBase {
  readonly structureType = DiscordStructure.User;
  /**
   * The ID of this user.
   * @type {string}
   */
  readonly id: string;
  /**
   * The user's avatar hash.
   * @type {string | null}
   */
  avatar: string | null;
  /**
   * Whether the user belongs to an OAuth2 application.
   * @type {boolean}
   */
  bot: boolean;
  /**
   * The user's 4-digit discord-tag.
   * @type {string}
   */
  discriminator: string;
  /**
   * The user's email.
   * @type {string | null}
   */
  email: string | null;
  /**
   * The flags on this user's account.
   * @type {UserFlags}
   */
  flags: UserFlags;
  /**
   * The public flags on this user's account.
   * @type {UserFlags}
   */
  publicFlags: UserFlags;
  /**
   * The type of Nitro subscription on this user's account.
   * @type {UserPremiumType}
   */
  premiumType: UserPremiumType;
  /**
   * The user's chosen language option.
   * @type {string}
   */
  locale: string;
  /**
   * The user's username, not unique across the platform.
   * @type {string}
   */
  username: string;
  /**
   * Whether the user has two factor enabled on their account.
   * @type {boolean}
   */
  mfaEnabled: boolean;
  /**
   * Whether the email on this account has been verified.
   * @type {boolean}
   */
  verified: boolean;
  /**
   * Whether the user is an Official Discord System user (part of the urgent message system).
   * @type {boolean}
   */
  system: boolean;

  /**
   * Creates a new instance of User.
   * @param {Client} client The client.
   * @param {APIUser} data The decoded user data.
   */
  constructor(client: Client, data: APIUser);

  /**
   * The tag of this user.
   * @type {string}
   */
  get tag(): string;

  /**
   * The mention string for this user.
   * @type {string}
   */
  get mention(): string;

  /**
   * The default avatar url for this user.
   * @type {string}
   */
  get defaultAvatarUrl(): string;

  /**
   * The URL for this user's avatar.
   * @param {ImageURLOptions} [options] The options for the url.
   * @returns {string | null}
   */
  avatarURL(options?: ImageURLOptions): string | null;

  /**
   * Gets an existing DM channel or creates one.
   * @returns {DMChannel}
   */
  dm(): Promise<DMChannel>;

  /**
   * The display avatar url for this user.
   * @param {ImageURLOptions} [options] The options for the avatar.
   * @returns {string}
   */
  displayAvatarURL(options?: ImageURLOptions): string;

  /**
   * Get the string representation of this user.
   * @returns {string}
   */
  toString(): string;

  /**
   * Updates this user with data from the api.
   * @param {APIUser} data
   * @protected
   */
  protected _patch(data: APIUser): this;
}

export class VoiceRegion {
  /**
   * Unique ID for the region.
   * @type {string}
   */
  readonly id: string;
  /**
   * Name of the region.
   * @type {string}
   */
  readonly name: string;
  /**
   * True if this is a vip-only server.
   * @type {boolean}
   */
  readonly vip: boolean;
  /**
   * True for a single server that is closest to the current user's client.
   * @type {boolean}
   */
  readonly optimal: boolean;
  /**
   * Whether this is a deprecated voice region (avoid switching to these).
   */
  readonly deprecated: boolean;
  /**
   * Whether this is a custom voice region (used for events/etc).
   * @type {boolean}
   */
  readonly custom: boolean;

  /**
   * @param {APIVoiceRegion} data The voice region data from discord.
   */
  constructor(data: APIVoiceRegion);

  /**
   * Get the json representation of this voice region.
   * @returns {APIVoiceRegion}
   */
  toJSON(): APIVoiceRegion;
}

export class MemoryEngine extends Emitter {
  /**
   * The janitor for this engine.
   * @type {Janitor}
   */
  readonly janitor: Janitor;
  /**
   * The limits for each discord structure.
   * @type {Map<DiscordStructure, number>}
   */
  readonly limits: Map<DiscordStructure, number>;
  /**
   * The maps for each structure.
   * @type {Record<DiscordStructure, Map<string, *>>}
   * @protected
   */
  protected _maps: Partial<Record<DiscordStructure, Collection<string, Cached<Dictionary>>>>;
  /**
   * Options provided to this engine.
   * @type {EngineOptions}
   * @protected
   */
  protected _options: Required<EngineOptions>;

  /**
   * @param {EngineOptions} options The options for this engine.
   */
  constructor(options?: EngineOptions);

  on(event: "debug", listener: (message: string) => void): this;
  on(event: "error", listener: (error: Error | string) => void): this;

  /**
   * Adds an item to the cache.
   * @param {DiscordStructure} structure The structure.
   * @param {*} id The identifier.
   * @param {Cached<*>} data The data that's being cached.
   */
  set<V extends Dictionary = Dictionary>(structure: DiscordStructure, id: string, data: V | Cached<V>): V | Cached<V>;

  /**
   * Clears the cache for a structure.
   * @param {DiscordStructure} structure The structure to clear.
   */
  clear(structure: DiscordStructure): MemoryEngine;

  /**
   * Deletes an item from the cache.
   * @param {DiscordStructure} structure The structure that is getting deleted.
   * @param {*} id ID of the item to delete.
   */
  delete(structure: DiscordStructure, id: string): boolean;

  /**
   * Get an item from the cache.
   * @param {DiscordStructure} structure The type of item to get.
   * @param {string} id The ID of the item to get.
   */
  get<V extends Dictionary = Dictionary>(structure: DiscordStructure, id: string): Cached<V> | undefined;

  /**
   * Get an item from the cache.
   * @param {DiscordStructure} structure The type of item to get.
   * @param {string} id The ID of the item to get.
   */
  has(structure: DiscordStructure, id: string): boolean;

  /**
   * Gets all items from the cache.
   * @param {DiscordStructure} structure The type of items to get.
   * @param {GetAllOptions} options Options to use.
   */
  all<V extends Dictionary = Dictionary>(structure: DiscordStructure, options?: GetAllOptions): Collection<string, Cached<V>>;

  /**
   * Gets a map for a specific structure.
   * @param {DiscordStructure} structure The structure.
   * @protected
   */
  protected getMap<V extends Dictionary = Dictionary>(structure: DiscordStructure): Collection<string, Cached<V>>;
}

export type Cached<V extends Dictionary> = V & {
  cachedAt: number;
};

export interface GetAllOptions extends Dictionary {
  /**
   * The amount of items to return.
   * @type {number}
   */
  limit: number;
}

export interface EngineOptions {
  /**
   * The limit for each structure.
   * @type {number | Map<DiscordStructure | number>}
   */
  limit?: number | Map<DiscordStructure, number>;
  /**
   * The jobs for the janitor.
   * @type {JanitorJobs}
   */
  janitor?: JanitorJobs;
  /**
   * Whether to remove an item from the cache if the limit has been reached.
   * @type {boolean}
   */
  removeOneOnFull?: boolean;
}

export class Janitor {
  /**
   * The engine this janitor belongs to.
   * @type {MemoryEngine}
   */
  readonly engine: MemoryEngine;
  /**
   * The jobs that janitor has.
   * @type {Map<DiscordStructure, Job>}
   */
  readonly jobs: Map<DiscordStructure, Job>;

  /**
   * @param {MemoryEngine} engine The engine this janitor belongs to.
   * @param {JanitorJobs} jobs The jobs that this janitor has.
   */
  constructor(engine: MemoryEngine, jobs?: JanitorJobs);

  /**
   * Starts the janitor.
   */
  start(): void;
}

export type JanitorJobs = Map<DiscordStructure, Job> | Partial<Record<DiscordStructure, Job>>;

export abstract class Job<O extends JobOptions = JobOptions> {
  /**
   * The name of this job.
   * @type {string}
   */
  readonly name: string;
  /**
   * The interval in which this job runs.
   * @type {number}
   */
  readonly interval: number;
  /**
   * The current shift of this job.
   * @type {?CurrentShift}
   */
  shift?: CurrentShift;
  /**
   * The options provided to this job.
   * @type {JobOptions}
   */
  protected _options: O;

  /**
   * @param {string} name The name of this job.
   * @param {JobOptions} options Options for the job.
   */
  constructor(name: string, options: O);

  /**
   * Initializes this job.
   * @returns {boolean}
   */
  start(...args: unknown[]): void;

  /**
   * Quits the job (waits for the current shift to end and
   */
  quit(): Promise<void>;

  /**
   * Doe the job.
   * @returns {number}
   */
  abstract do(shift: Omit<CurrentShift, "promise">, ...args: unknown[]): Promise<unknown>;
}

export interface JobOptions {
  interval: string | number;
}

export interface CurrentShift {
  startedAt: number;
  id: number;
  promise: Promise<unknown>;
}

export abstract class Jobs {
  /**
   * The default job for all structures.
   * @param {DiscordStructure} structure The structure this job is for.
   * @param {SweeperJobOptions} options The options for this job.
   * @constructor
   */
  static Default({ structure, ...options }: SweeperJobOptions & {
    structure: DiscordStructure;
  }): Job;

  /**
   * An official message job for engines.
   * @param {SweeperJobOptions} options
   * @constructor
   */
  static Message(options: SweeperJobOptions): Job;
}

export interface SweeperJobOptions extends JobOptions {
  lifetime: number | string;
}

export class Client extends Emitter {
  /**
   * All cached guilds for the current session.
   * @type {GuildManager}
   */
  readonly guilds: GuildManager;
  /**
   * All cached users for the current session.
   * @type {UserManager}
   */
  readonly users: UserManager;
  /**
   * All cached channels for the current session.
   * @type {ChannelManager}
   */
  readonly channels: ChannelManager;
  /**
   * All cached DMs for the current session.
   * @type {DMChannelManager}
   */
  readonly dms: DMChannelManager;
  /**
   * The current user.
   * @type {ClientUser?}
   */
  user?: ClientUser;
  /**
   * The token of this client.
   * @type {string}
   */
  token: string;

  /**
   * Creates a new Client.
   * @param {ClientOptions} options The options.
   */
  constructor(options?: ClientOptions);

  /**
   * The internal sharding manager instance.
   * @type {ShardManager}
   */
  get ws(): ShardManager;

  /**
   * An interface for the discord api and cdn.
   * @type {API}
   */
  get api(): API;

  /**
   * The data manager for this client.
   * @type {DataManager}
   */
  get data(): DataManager;

  /**
   * Connects the bot to the discord gateway.
   * @param {string} [token] The bot token.
   * @returns {Client}
   */
  connect(token?: string): Promise<this>;

  /**
   * Destroys this client.
   */
  destroy(): void;

  /**
   * Listen for a client event.
   * @param {string} event The event to listen for.
   * @param {Function} listener The event listener.
   */
  on<K extends keyof ClientEvents>(event: K, listener: ClientEvents[K]): this;
}

export type ClientEvents = {
  messageCreate: (message: Message) => void;
  messageUpdate: (old: Readonly<Message>, updated: Message) => void;
  debug: (message: string) => void;
  error: (error: any, message: string | undefined) => void;
} & Record<"ready" | string, (...args: any[]) => void>;

export interface ClientOptions {
  /**
   * Options for the sharding manager.
   */
  ws?: ISMOptions;
  /**
   * Options for the REST manager.
   */
  rest?: APIOptions;
  /**
   * Options for data.
   */
  data?: DataOptions;
}

export class MessageManager extends BaseManager<Message> {
  /**
   * The text channel.
   */
  readonly channel: TextBasedChannel;

  /**
   * Creates a new instanceof MessageManager.
   * @param {TextBasedChannel} channel The text channel instance.
   */
  constructor(channel: TextBasedChannel);

  /**
   * Deletes a message from the channel.
   * @param {string} message The message to delete.
   * @param {MessageDeleteOptions} options The delete options.
   * @returns {Message} The deleted message.
   */
  remove(message: MessageResolvable, options?: MessageDeleteOptions): Promise<Message | null>;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  new(builder: Builder | MessageBuilder): Promise<Message[]>;
  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  new(options: MessageOptions): Promise<Message[]>;
  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  new(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Resolves user message parameters into api messages.
   * @param {MessageAdd} content The message content or builder
   * @param {MessageOptions} options The message options.
   */
  resolveMessageData(content: MessageAdd, options?: MessageOptions): Promise<RequestData[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Fetches a single message from the channel.
   * @param {string} id ID of the message to fetch.
   * @param {boolean} [force] Whether to skip checking if the message is already cached.
   * @returns {Promise<Message>} The fetched (or cached) message.
   */
  fetch(id: string, force?: boolean): Promise<Message>;
  /**
   * Fetches 2-100 messages from the channel.
   * @param {MessageFetchOptions} options The fetch options.
   * @returns {Promise<Collection<string, Message>>} The fetched messages.
   */
  fetch(options: MessageFetchOptions): Promise<Collection<string, Message>>;
}

export type Builder = (builder: MessageBuilder) => MessageBuilder | Promise<MessageBuilder>;
export type MessageResolvable = BaseResolvable<Message>;
export type MessageAdd = string | Embed | Builder | MessageBuilder | MessageOptions;

export interface BulkDeleteOptions {
  filterOld?: boolean;
  reason?: string;
}

export interface MessageFetchOptions {
  around?: string;
  before?: string;
  after?: string;
  limit?: number;
}

export interface MessageDeleteOptions {
  /**
   * How long to wait before deleting the message.
   */
  wait?: string | number;
  /**
   * The reason for deleting the message.
   */
  reason?: string;
}

/**
 * Modified version of @klasa/core's message builder.
 */
export class MessageBuilder {
  /**
   * The message data.
   * @type {MessageData}
   */
  body: PartialExcept<MessageData, "allowed_mentions">;
  /**
   * The files to attach.
   * @type {File[]}
   */
  files: File[];

  /**
   * Creates a new instanceof MessageBuilder.
   * @param {MessageOptions | MessageEditOptions} data The data to pre-define.
   */
  constructor(data?: MessageOptions | MessageEditOptions);

  /**
   * Set the content of this message.
   * @param {string} [content]
   */
  content(content?: string | null): MessageBuilder;

  /**
   * Sets the embed of this message.
   * @param {APIEmbed | null | Embed} [embed] The embed to set
   */
  embed(embed?: APIEmbed | null | Embed): MessageBuilder;

  /**
   * Sets the nonce of this message
   * @param {string | number} [nonce] The nonce to set
   * @returns {MessageBuilder}
   */
  nonce(nonce?: number | string): MessageBuilder;

  /**
   * Adds a message attachment to this message
   * @param {File | File[]} file The attachment
   * @returns {MessageBuilder}
   */
  attach(file: File | File[]): MessageBuilder;

  /**
   * Change whether this message will have text-to-speech.
   * @param {boolean} [tts] The tts of this message
   * @returns {MessageBuilder}
   */
  tts(tts?: boolean): MessageBuilder;

  /**
   * Makes @everyone and @here actually ping people.
   * @returns {MessageBuilder}
   */
  parseEveryone(): MessageBuilder;

  /**
   * Allow specific users to be mentioned.
   * @param {...string} users user The {@link User user}s you want to mention.
   * @returns {MessageBuilder}
   */
  parseUsers(...users: string[]): MessageBuilder;

  /**
   * Allow specific roles to be pinged.
   * @param {...string} roles The {@link Role role}s you want to mention.
   * @returns {MessageBuilder}
   */
  parseRoles(...roles: string[]): MessageBuilder;

  /**
   * Splits the message into chunks
   * @param {SplitOptions} [options]
   * @returns {RequestData[]}
   */
  split(options?: SplitOptions): RequestData[];

  /**
   * Internal shared method to split the content by.
   * @param {SplitOptions} [options]
   */
  protected _split({ maxLength, char, prepend, append }?: SplitOptions): string[];
}

export type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Required<Pick<T, K>>;
export type RequiredExcept<T, K extends keyof T> = Partial<Pick<T, K>> & Required<Omit<T, K>>;

export interface MessageData {
  content?: string | null;
  embed?: APIEmbed | null;
  nonce?: number | string;
  tts?: boolean;
  allowed_mentions?: Required<AllowedMentions>;
}

export interface MessageEditOptions {
  content?: string | null;
  embed?: APIEmbed | null;
  flags?: MessageFlags;
}

export interface AllowedMentions {
  parse?: ("users" | "roles" | "everyone")[];
  roles?: string[];
  users?: string[];
}

export interface MessageOptions extends Omit<MessageData, "allowed_mentions"> {
  files?: File[];
  allowedMentions?: Required<AllowedMentions>;
}

export interface SplitOptions {
  maxLength?: number;
  char?: string;
  prepend?: string;
  append?: string;
}

export class MemberRoleManager extends ProxyManager<Role> {
  /**
   * The member this role manager belongs to.
   * @type {Member}
   */
  readonly member: Member;

  /**
   * Creates a new instanceof MemberRoleManager.
   * @param {Member} member The member this manager belongs to.
   * @param {Array<string>} [roles] The roles.
   */
  constructor(member: Member, roles?: string[]);

  /**
   * The guild the channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Adds a role to the member.
   * @param {RoleResolvable} role
   * @param {string} [reason]
   */
  add(role: RoleResolvable, reason?: string): Promise<this>;

  /**
   * Removes a role from the member.
   * @param {RoleResolvable} role
   * @param {string} [reason]
   */
  remove(role: RoleResolvable, reason?: string): Promise<this>;
}

export class PinnedMessageManager extends ProxyManager<Message> {
  /**
   * The channel that this manager belongs to.
   * @type {TextBasedChannel}
   */
  readonly channel: TextBasedChannel;

  /**
   * @param {TextBasedChannel} channel
   * @param {snowflake[]} [pinned]
   */
  constructor(channel: TextBasedChannel, pinned?: snowflake[]);

  /**
   * Unpins a message to the channel.
   * @param {MessageResolvable} message The message to unpin.
   * @param {string} [reason] Reason for unpinning the message.
   * @returns {Promise<Message>} The unpinned message.
   */
  remove(message: MessageResolvable, reason?: string): Promise<Message | null>;

  /**
   * Pins a message to the channel.
   * @param {MessageResolvable} message The message to pin.
   * @param {string} [reason] Reason for pinning the message.
   * @returns {Promise<Message>} The pinned message.
   */
  add(message: MessageResolvable, reason?: string): Promise<Message | null>;
}

export class BanManager extends BaseManager<Ban> {
  /**
   * The guild this ban manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof BanManager.
   * @param {Guild} guild The {@link Guild guild} instance.
   */
  constructor(guild: Guild);

  /**
   * Create a guild ban, and optionally delete previous messages sent by the banned user.
   * @param {UserResolvable} user The user to ban.
   * @param {BanOptions} [options] The ban options. {@see BanOptions}
   * @returns {Promise<BanManager>} The {@link BanManager ban manager}
   */
  new(user: UserResolvable, options?: BanOptions): Promise<BanManager>;

  /**
   * Remove the ban for a user.
   * @param {UserResolvable} user The {@link User user} to unban.
   * @param {string} [reason] The audit-log ban reason.
   * @returns {Promise<Ban | null>} The removed {@link Ban ban}.
   */
  remove(user: UserResolvable, reason?: string): Promise<Ban | null>;

  /**
   * Fetches a ban from the guild.
   * @param {FetchBans} options The fetch options.
   * @param {boolean} force Whether to skip checking if the ban is already cached.
   * @returns {Promise<Ban>} The fetched (or cached) {@link Ban ban}.
   */
  fetch(options: {
    id: string;
    cache?: boolean;
  }, force?: boolean): Promise<Ban>;
  /**
   * Fetches all bans for the guild and populates a new {@link Collection collection}.
   * @param {FetchBans} options The fetch options.
   * @returns {Promise<Collection<string, Ban>>} The new {@link Collection collection}.
   */
  fetch(options: {
    cache: false;
  }): Promise<Collection<string, Ban>>;
  /**
   * Fetches all bans for the guild and populates this manager.
   * @param {FetchBans} options The fetch options.
   * @returns {Promise<BanManager>} The ban manager.
   */
  fetch(options: {
    cache?: true;
  }): Promise<BanManager>;
}

export interface BanOptions {
  /**
   * Reason for the ban
   */
  reason?: string;
  /**
   * Number of days to delete messages for (0-7)
   */
  days?: number;
}

export interface FetchBans {
  id?: string;
  cache?: boolean;
}

export class BaseManager<S extends Base> {
  /**
   * The class to use.
   * @type {Class}
   * @protected
   */
  protected class: Class<S>;
  /**
   * The structure this manager manages.
   * @type {DiscordStructure}
   * @protected
   */
  protected structure: DiscordStructure;

  /**
   * @param {Client} client The client instance.
   * @param {ManagerData} data The data for this manager.
   */
  constructor(client: Client, data: ManagerData<S>);

  /**
   * The number of cached items in this
   */
  get size(): number;

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * The engine that this manager uses to cache.
   * @type {MemoryEngine}
   */
  get engine(): MemoryEngine;

  /**
   * The custom inspect text.
   * @returns {string}
   */
  get [Util.inspect.custom](): string;

  /**
   * The cache of this base manager.
   * @type {Collection<string, Base>}
   */
  get cache(): Collection<string, S>;

  /**
   * @returns {typeof Collection}
   */
  static [Symbol.species](): typeof Collection;

  /**
   * Resolves something into a usable object.
   * @param {BaseResolvable} item The item to resolve.
   * @returns {Promise<Base | null>}
   */
  resolve(item: BaseResolvable<S>): S | null;

  /**
   * Resolves something into an ID
   * @param {string | Base} data The data to resolve.
   * @returns {string} The resolved ID or null if nothing was found.
   */
  resolveId(data: BaseResolvable<S>): string | null;

  /**
   * Clears the cache.
   * @type {string}
   */
  clear(): BaseManager<S>;

  /**
   * Gets an item from the cache.
   * @param {string} id
   * @returns {Base | null}
   */
  get(id: string): S | undefined;

  /**
   * Whether an item is in the cache.
   * @param {string} id The ID of the item to check for.
   * @returns {boolean}
   */
  has(id: string): boolean;

  /**
   * The value iterator for this manager.
   * @returns {IterableIterator<string, Base>}
   */
  [Symbol.iterator](): IterableIterator<[ string, S ]>;

  /**
   * Runs a function on each entry of this manager
   * @param {Function} fn The function ran each iteration.
   * @param {any} thisArg Optional binding for the predicate.
   * @returns {Collection<string, Base>}
   */
  forEach(fn: (value: S, key: string, col: Map<string, S>) => void, thisArg?: unknown): void;

  /**
   * Returns a filtered manager based on the provided predicate.
   * @param fn The predicate used to determine whether or not an entry can be passed to the new collection.
   * @param {any} thisArg Optional binding for the predicate.
   * @returns {Collection<string, Base>}
   */
  filter(fn: (value: S, key: string, col: this) => boolean, thisArg?: unknown): Collection<string, S>;

  /**
   * The json representation of this manager.
   * @returns {Array<string>}
   */
  toJSON(): string[];

  /**
   * The keys iterator.
   * @returns {AsyncIterator<[string, Base]>}
   */
  keys(): IterableIterator<string>;

  /**
   * The keys iterator.
   * @returns {AsyncIterator<[string, Base]>}
   */
  entries(): IterableIterator<[ string, S ]>;

  /**
   * The keys iterator.
   * @returns {AsyncIterator<[string, Base]>}
   */
  values(): IterableIterator<S>;

  /**
   * Adds an item to this manager.
   * @param {Base} item The item to add.
   * @protected
   */
  protected _set(item: S): S;

  /**
   * Adds an item to this manager.
   * @param {Dictionary} data
   * @param {...*} args Args to pass to the class.
   * @protected
   */
  protected _add(data: Dictionary, ...args: unknown[]): S;
}

export type BaseResolvable<T extends Base> = T | string | {
  id: string;
};

export interface BaseManager<S extends Base> {
  /**
   * The first item in this manager.
   * @type {Base | null}
   */
  first: S | null;
  /**
   * The last item in this manager.
   * @type {Base | null}
   */
  last: S | null;

  /**
   * Tests whether or not an entry in this manager meets the provided predicate.
   * @param {Function} predicate A predicate that tests all entries.
   * @param {any} thisArg An optional binding for the predicate function.
   */
  some(predicate: (value: S, key: string, col: this) => unknown, thisArg?: unknown): boolean;

  /**
   * Collection#forEach but it returns the manager instead of nothing.
   * @param {Function} fn The function to be ran on all entries.
   * @param {any} thisArg An optional binding for the fn parameter.
   */
  each(fn: (value: S, key: string, col: this) => unknown, thisArg?: unknown): this;

  /**
   * Finds a value using a predicate from this manager.
   * @param {Function} fn Function used to find the value.
   * @param {any} thisArg Optional binding to use.
   */
  find(fn: (value: S, key: string, col: this) => boolean, thisArg?: unknown): S | null;

  /**
   * Reduces this manager down into a single value.
   * @template {any} A
   * @param {Function} fn The function used to reduce this manager.
   * @param {A} acc The accumulator.
   * @param {any} thisArg Optional binding for the reducer function.
   * @returns
   */
  reduce<A>(fn: (acc: A, value: S, key: string, col: this) => A, acc: A, thisArg?: unknown): A;

  /**
   * Maps this manager into an array. Array#map equivalent.
   * T - The type of element of each element in the returned array.
   * @template {any} T
   * @param {Function} fn Function used to map values to an array.
   * @param {any} thisArg Optional binding for the map function.
   * @returns {T[]}
   */
  map<T>(fn: (value: S, key: string, col: this) => T, thisArg?: unknown): T[];

  /**
   * Returns a clone of this collection.
   * @returns {Collection<string, Base>}
   */
  clone(): Collection<string, S>;
}

export interface ManagerData<S extends Base> {
  /**
   * The class to use when instantiating things.
   * @type {Class}
   */
  class: Class<S>;
  /**
   * The structure that this manager handles.
   * @type {DiscordStructure}
   */
  structure: DiscordStructure;
}

export class ChannelManager extends BaseManager<Channel> {
  /**
   * Creates a new instanceof ChannelManager
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Get a channel.
   * @param {string} id ID of the channel to get.
   * @returns {Channel} The channel
   */
  get<T extends Channel = Channel>(id: string): T | undefined;

  /**
   * Adds a new channel to this manager.
   * @private
   */
  protected _add(data: APIChannel, guild?: Guild): Channel;
}

export class DMChannelManager extends BaseManager<DMChannel> {
  /**
   * Creates a new instanceof DMChannelManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Closes a DM channel.
   * @param {DMResolvable} channel The DM to close.
   * @returns {DMChannel} The closed DM channel.
   */
  close(channel: DMResolvable): Promise<DMChannel>;

  /**
   * Creates a new DM between the current user and someone else.
   * @param {BaseResolvable} user The user.
   * @returns {DMChannel} The new dm channel.
   */
  new(user: UserResolvable): Promise<DMChannel>;

  /**
   * Adds a new DM channel to this manager.
   * @param {APIChannel} data
   * @protected
   */
  protected _add(data: APIChannel): DMChannel;
}

export type DMResolvable = BaseResolvable<DMChannel>;

export class GuildChannelManager extends BaseManager<GuildChannel> {
  /**
   * The guild this channel cache belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof GuildChannelCache
   * @param {Guild} guild The {@link Guild guild} instance.
   */
  constructor(guild: Guild);

  /**
   * Get a guild channel.
   * @param {string} id ID of the channel to get.
   * @returns {GuildChannel} The guild channel
   */
  get<T extends GuildChannel = GuildChannel>(id: string): T | undefined;

  /**
   * Removes a channel from the guild.
   * @param {GuildChannel} channel The channel to remove.
   * @param {string} [reason] The reason that the channel was deleted.
   * @returns {GuildChannel | null} The removed channel.
   */
  remove<T extends GuildChannel = GuildChannel>(channel: BaseResolvable<T>, reason?: string): Promise<T | null>;

  /**
   * Fetches a {@link GuildChannel guild channel} from the discord api.
   * @param {string} channelId ID of the channel to fetch.
   * @param {boolean} [force] Skips checking if the channel is already cached.
   * @returns {Promise<GuildChannel>} The fetched channel.
   */
  fetch<T extends GuildChannel = GuildChannel>(channelId: string, force?: boolean): Promise<T>;
  /**
   * Fetches all channels in the guild.
   * @returns {Promise<Collection<string, GuildChannel>>} The {@link GuildChannel guild channel} cache.
   */
  fetch(): Promise<Collection<string, GuildChannel>>;

  /**
   * Adds a new item to this manager.
   * @data {APIChannel} data
   * @private
   */
  protected _add(data: APIChannel): GuildChannel;
}

export class GuildManager extends BaseManager<Guild> {
  /**
   * Creates a new instanceof GuildManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Deletes this guild. Current user must be the owner.
   * @param {BaseResolvable} guild The guild to remove.
   * @returns {Guild | null} The guild that was removed.
   */
  remove(guild: GuildResolvable): Promise<Guild | null>;

  /**
   * Leaves a guild.
   * @param {GuildResolvable} guild The guild to leave.
   * @returns {?Guild} The guild that the current user left.
   */
  leave(guild: GuildResolvable): Promise<Guild | null>;

  /**
   * Fetches a guild from the discord api.
   * @param {string} guild The ID of the guild to fetch.
   * @returns {Promise<Guild>} The fetched guild.
   */
  fetch(guild: string): Promise<Guild>;
}

export type GuildResolvable = BaseResolvable<Guild>;

export class MemberManager extends BaseManager<Member> {
  /**
   * The guild this member manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof MemberManager.
   * @param {Guild} guild The guild instance.
   */
  constructor(guild: Guild);

  /**
   * Resolves something into a guild member {@link Member member}.
   * @param {MemberResolvable} item The data to resolve.
   * @returns {Member | null} The resolved ID or null if nothing was found.
   */
  resolve(item: BaseResolvable<Member>): Member | null;

  /**
   * Resolves something into an ID.
   * @param {MemberResolvable} data The data to resolve.
   * @returns {string | null} The resolved ID or null if nothing was found.
   */
  resolveId(data: MemberResolvable): string | null;

  /**
   * Kicks a member or user from the {@link Guild guild}.
   * @param {MemberResolvable} target The {@link Member member} or {@link User user} to kick.
   * @param {string} [reason] The reason for the audit log entry.
   * @returns {Member | null} The kicked {@link Member member}.
   */
  kick(target: MemberResolvable, reason?: string): Promise<Readonly<Member> | null>;

  /**
   * Bans a member or user from the {@link Guild guild}.
   * @param {MemberResolvable} target The {@link Member member} or {@link User user} to ban.
   * @param {BanOptions} [options] The ban options.
   * @returns {Member | null} The banned {@link Member member}.
   */
  ban(target: MemberResolvable, options?: BanOptions): Promise<MemberResolvable | null>;

  /**
   * Fetch a member from the discord api.
   * @param {string} id User ID of the member to fetch.
   * @param {boolean} [force] Whether to skip checking if the member is already cached.
   * @returns {Member} The fetched (or cached) member.
   */
  fetch(id: string, force?: boolean): Promise<Member>;
  /**
   * Fetch 1-1000 members from the guild.
   * @param {FetchMembers} options Options to use when fetching.
   * @returns {Collection<string, Member>} The fetched members.
   */
  fetch(options?: FetchMembers): Promise<Collection<string, Member>>;

  /**
   * Get the number of members that would be removed in a 'non-dry' prune.
   * @param {DryPruneOptions} options The options for the 'dry' prune.
   * @param {string} [reason] The audit-log reason.
   * @returns {number} The number of members that would be removed in a 'non-dry' prune.
   */
  prune(options: DryPruneOptions, reason?: string): Promise<number>;
  /**
   * Starts a member prune operation.
   * @param {PruneOptions} options Options for the prune operation.
   * @param {string} [reason] The audit-log reason.
   * @returns {number | null} The number or removed members, only null if the 'computePruneCount' option was omitted or set to false.
   */
  prune(options: PruneOptions, reason?: string): Promise<number | null>;

  /**
   * Adds a new member to this manager.
   * @param {APIGuildMember} data
   * @private
   */
  protected _add(data: APIGuildMember): Member;
}

export type MemberResolvable = BaseResolvable<User | Member>;

export interface FetchMembers {
  /**
   * Max number of members to fetch (1-1000)
   */
  limit?: number;
  /**
   * The highest user id in the previous page
   */
  after?: string;
}

export interface DryPruneOptions {
  /**
   * If set to true:
   * Returns the number ('pruned' property) of members that would be removed in a "non-dry" prune operation.
   */
  dry: true;
  /**
   * Number of days to count prune for (1 or more)
   */
  days?: number;
  /**
   * Role(s) to include
   */
  includeRoles?: string | string[];
}

export interface PruneOptions extends Omit<DryPruneOptions, "dry"> {
  /**
   * Whether 'pruned' is returned, discouraged for large guilds.
   */
  computePruneCount?: boolean;
  /**
   * Requests a prune operation.
   */
  dry?: false;
}

export class OverwriteManager extends BaseManager<PermissionOverwrite> {
  /**
   * The channel this overwrite manager belongs to.
   * @type {GuildChannel}
   */
  readonly channel: GuildChannel;

  /**
   * Creates a new instanceof OverwriteManager.
   * @param {GuildChannel} channel The guild channel this manager belongs to.
   */
  constructor(channel: GuildChannel);

  /**
   * The guild the channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Adds a new permission overwrite to the channel permissions.
   * @param {string} id The member or role.
   * @param {OverwriteOptions} options The overwrite options.
   */
  add(id: string, options: RequiredExcept<OverwriteOptions, "reason">): Promise<PermissionOverwrite>;
  /**
   * Adds a new permission overwrite to the channel permissions.
   * @param {Role} target The role.
   * @param {OverwriteOptions} options The overwrite options.
   */
  add(target: Role, options: Omit<OverwriteOptions, "type">): Promise<PermissionOverwrite>;
  /**
   * Adds a new permission overwrite to the channel permissions.
   * @param {Member} target The member.
   * @param {OverwriteOptions} options The overwrite options.
   */
  add(target: Member, options: Omit<OverwriteOptions, "type">): Promise<PermissionOverwrite>;

  /**
   * Get the overwrites for a guild member.
   * @param {Member} member The member
   */
  for(member: Member): MemberOverwrites;
  /**
   * Get the overwrites for a role.
   * @param {Role} role The role.
   * @returns {RoleOverwrites}
   */
  for(role: Role): RoleOverwrites;
}

export interface OverwriteOptions {
  type?: "role" | "member";
  allow: PermissionResolvable;
  deny: PermissionResolvable;
  reason?: string;
}

export interface MemberOverwrites {
  everyone?: PermissionOverwrite;
  member?: PermissionOverwrite;
  roles: PermissionOverwrite[];
}

export interface RoleOverwrites {
  everyone?: PermissionOverwrite;
  role?: PermissionOverwrite;
}

export class PresenceManager extends BaseManager<Presence> {
  /**
   * The guild this manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof PresenceManager.
   * @param {Guild} guild The guild this manager belongs to.
   */
  constructor(guild: Guild);
}

export class ProxyManager<S extends Base> extends Collection<string, S> {
  /**
   * The manager this proxies.
   * @type {BaseManager}
   */
  readonly manager: BaseManager<S>;

  /**
   * Creates a new proxy manager.
   * @param {BaseManager} manager
   * @param {string[]} [keys]
   */
  constructor(manager: BaseManager<S>, keys?: string[]);

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * Returns the number of keys in this collection.
   * @type {number}
   */
  get size(): number;

  /**
   * Returns the string tag of this instance.
   * @type {string}
   */
  get [Symbol.toStringTag](): string;

  /**
   * Get am item from this shared collection.
   * @param {any} key
   * @returns {* | undefined}
   */
  get(key: string): S | undefined;

  /**
   * Whether this shared collections contains a key.
   * @param {any} key
   * @returns {boolean}
   */
  has(key: string): boolean;

  /**
   * Adds a key to the
   * @param {any} key
   * @returns {ProxyManager}
   */
  set(key: string): this;

  /**
   * Removes a key from this store.
   * @param {any} key
   * @returns {boolean}
   */
  delete(key: string): boolean;

  /**
   * Clears all keys from this store.
   * @returns {ProxyManager}
   */
  clear(): this;

  /**
   * Executes a provided function for each k/v pair in the store.
   * @param {Function} callbackFn
   * @param {any} [thisArg]
   */
  forEach(callbackFn: (value: S, key: string, map: Map<string, S>) => void, thisArg?: unknown): void;

  /**
   * Returns a new iterator that contains the k/v pairs for each element in this store.
   * @returns {IterableIterator}
   */
  [Symbol.iterator](): IterableIterator<[ string, S ]>;

  /**
   * Returns a new iterator that contains the k/v pairs for each element in this store.
   * @returns {IterableIterator}
   */
  entries(): IterableIterator<[ string, S ]>;

  /**
   * Returns a new iterator that contains the keys for each element in this store.
   * @returns {IterableIterator<*>}
   */
  keys(): IterableIterator<string>;

  /**
   * Returns a new iterator that contains all the values for each element in this store.
   * @returns {IterableIterator<*>}
   */
  values(): IterableIterator<S>;
}

export class RoleManager extends BaseManager<Role> {
  /**
   * The guild this role manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof RoleManager.
   * @param {Guild} guild The guild this role manager belongs to.
   */
  constructor(guild: Guild);

  /**
   * The highest role based on position in this store.
   * @type {Role | null}
   */
  get highest(): Role | null;

  /**
   * Add a role to this store.
   * @param {RoleAddOptions} data The role data.
   * @param {string} [reason] The reason for adding this role..
   */
  add(data: RoleAddOptions, reason?: string): Promise<Role>;

  /**
   * Removes a role from the role list.
   * @param {BaseResolvable} role The role to remove.
   * @param {string} [reason] The reason for removing the role.
   */
  remove(role: RoleResolvable, reason?: string): Promise<Role | null>;

  /**
   * Fetches a role from the discord api.
   * @param {string} role The ID of the role to fetch.
   * @param {boolean} [force] Skip checking if the role is already cached.
   * @returns {Promise<Role>} The fetched role.
   */
  fetch(role: string, force?: boolean): Promise<Role>;
  /**
   * Fetches all roles for the guild.
   * @returns {Promise<Collection<string, Role>>}
   */
  fetch(): Promise<Collection<string, Role>>;
}

export type RoleResolvable = BaseResolvable<Role>;

export interface RoleAddOptions {
  name?: string;
  permissions?: PermissionResolvable | number;
  color?: string | number;
  hoisted?: boolean;
  mentionable?: boolean;
}

export class UserManager extends BaseManager<User> {
  /**
   * Creates a new instanceof UserManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Fetches a user from the discord api.
   * @param {string} userId The ID of the user to fetch.
   * @returns {Promise<User>} The fetched user.
   */
  fetch(userId: string): Promise<User>;
}

export type UserResolvable = BaseResolvable<User>;

export class VoiceStateManager extends BaseManager<VoiceState> {
  /**
   * The guild instance.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof VoiceStateManager.
   * @param {Guild} guild The guild instance.
   */
  constructor(guild: Guild);
}

export abstract class Base {
  /**
   * The ID of this instance.
   * @type {string}
   */
  abstract readonly id: string;
  /**
   * The typeof discord structure this is.
   * @type {DiscordStructure}
   */
  abstract readonly structureType: DiscordStructure;

  /**
   * Creates a new instance of Base.
   * @param {Client} client The client instance.
   */
  protected constructor(client: Client);

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * Clones this instance.
   * @returns {Base}
   */
  _clone(): this;

  /**
   * Freezes this structure.
   * @returns {Readonly<this>}
   */
  _freeze(): Readonly<this>;

  /**
   * Get the JSON representation of this instance.
   * @returns {Dictionary}
   */
  toJSON(): Dictionary;

  /**
   * @param {...*} [data]
   * @protected
   */
  protected _patch(...data: unknown[]): this;
}

export const neo: Extender<Record<string, import("@neocord/utils").Class<any>>>;

export type Structures = {
  WelcomeChannel: typeof WelcomeChannel;
  WelcomeScreen: typeof WelcomeScreen;
  Ban: typeof Ban;
  Guild: typeof Guild;
  Invite: typeof Invite;
  Member: typeof Member;
  PermissionOverwrite: typeof PermissionOverwrite;
  Presence: typeof Presence;
  Role: typeof Role;
  VoiceState: typeof VoiceState;
  Message: typeof Message;
  User: typeof User;
  MessageAttachment: typeof MessageAttachment;
  CategoryChannel: typeof CategoryChannel;
  GuildChannel: typeof GuildChannel;
  NewsChannel: typeof NewsChannel;
  StoreChannel: typeof StoreChannel;
  VoiceChannel: typeof VoiceChannel;
  TextChannel: typeof TextChannel;
  DMChannel: typeof DMChannel;
  Channel: typeof Channel;
}

export abstract class SnowflakeBase extends Base {
  /**
   * The date when this object was created.
   * @type {Date}
   */
  get createdAt(): Date;

  /**
   * The time when this object was created.
   * @type {number}
   */
  get createdTimestamp(): number;

  /**
   * The snowflake data.
   * @type {Snowflake}
   */
  get snowflake(): DeconstructedSnowflake;
}

export enum Permission {
  CreateInstantInvite = 1,
  KickMembers = 2,
  BanMembers = 4,
  Administrator = 8,
  ManageChannels = 16,
  ManageGuild = 32,
  AddReactions = 64,
  ViewAuditLog = 128,
  PrioritySpeaker = 256,
  Stream = 512,
  ViewChannel = 1024,
  SendMessages = 2048,
  SendTTSMessage = 4096,
  MangeMessages = 8192,
  EmbedLinks = 16384,
  AttachFiles = 32768,
  ReadMessageHistory = 65536,
  MentionEveryone = 131072,
  UseExternalEmojis = 262144,
  ViewGuildInsights = 524288,
  Connect = 1048576,
  Speak = 2097152,
  MuteMembers = 4194304,
  DeafenMembers = 8388608,
  MoveMembers = 16777216,
  UseVAD = 33554432,
  ChangeNickname = 67108864,
  ManageNicknames = 134217728,
  ManageRoles = 268435456,
  ManageWebhooks = 536870912,
  ManageEmojis = 1073741824
}

export class Permissions extends BitField<PermissionResolvable> {
  /**
   * All Permission Flags.
   * @type {Permission}
   */
  static FLAGS: typeof Permission;
  /**
   * The default permissions for a role.
   * @type {number}
   */
  static DEFAULT: number;
  /**
   * Permissions that can't be influenced by channel overwrites, even if explicitly set.
   * @type {number}
   */
  static GUILD_SCOPE_PERMISSIONS: number;

  /**
   * Checks whether the bitfield has a permission, or any of multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override
   */
  any(permission: PermissionResolvable, checkAdmin?: boolean): boolean;

  /**
   * Checks whether the bitfield has a permission, or multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override
   */
  has(permission: PermissionResolvable, checkAdmin?: boolean): boolean;
}

export type PermissionResolvable =
  keyof typeof Permission
  | Permission
  | number
  | BitFieldObject
  | (keyof typeof Permission | number | BitFieldObject)[];

export abstract class ImageResolver {
  /**
   * Whether a buffer is of the jpeg format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isJpg(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the png format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isPng(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the webp format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isWebp(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the gif format
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isGif(buffer: Buffer): boolean;

  /**
   * Get the image format of a buffer.
   * @param {Buffer} buffer
   * @returns {ImageFormats | null}
   */
  static getImageFormat(buffer: Buffer): ImageFormats | null;

  /**
   * Resolves a buffer into a base64 string.
   * @param {Buffer | string} data
   * @returns {string}
   */
  static resolveBase64(data: Buffer | string): string;

  /**
   * Resolves a file.
   * @param {ImageResolvable} resource
   * @returns {Promise<Buffer>}
   */
  static resolveFile(resource: ImageResolvable): Promise<Buffer>;

  /**
   * Resolve an image into a base64
   * @param {ImageResolvable} data
   * @returns {Promise<string>}
   */
  static resolveImage(data: ImageResolvable): Promise<string>;
}

export type ImageResolvable = Buffer | Readable | string;

export enum ImageFormats {
  WEBP = "image/webp",
  GIF = "image/gif",
  PNG = "image/png",
  JPEG = "image/jpeg"
}

export enum ClientEvent {
  GuildAvailable = "guildAvailable",
  GuildUnavailable = "guildUnavailable",
  RoleCreate = "roleCreate",
  RoleDelete = "roleDelete",
  RoleUpdate = "roleUpdate"
}

export enum DebugTopic {
  PacketHandling = "packet handling",
  Janitor = "janitor"
}

export enum DiscordStructure {
  Guild = 0,
  Role = 1,
  Channel = 2,
  Emoji = 3,
  Presence = 4,
  Message = 5,
  Overwrite = 6,
  VoiceState = 7,
  DMChannel = 8,
  Ban = 9,
  Member = 10,
  User = 11,
  Invite = 12,
  GuildChannel = 13
}

export enum Color {
  Default = 0,
  White = 16777215,
  Aqua = 1752220,
  Green = 3066993,
  Blue = 3447003,
  Yellow = 16776960,
  Purple = 743868,
  LuminousVividPink = 15277667,
  Gold = 15844367,
  Orange = 15105570,
  Red = 15158332,
  Grey = 9807270,
  Navy = 3426654,
  DarkAqua = 1146986,
  DarkGreen = 2067276,
  DarkBlue = 2123412,
  DarkPurple = 7419530,
  DarkVividPink = 11342935,
  DarkGold = 12745742,
  DarkOrange = 11027200,
  DarkRed = 10038562,
  DarkGrey = 9936031,
  DarkerGrey = 8359053,
  LightGrey = 12370112,
  DarkNavy = 2899536,
  Blurple = 7506394,
  Greyple = 10070709,
  DarkButNotBlack = 2895667,
  NotQuiteBlack = 2303786
}

export type ColorResolvable = Color | keyof Color | number | string | [ number, number, number ];

export function makeSafeQuery(dict: Dictionary): Dictionary<string>;

/**
 * Parses a hex code or integer to a hex integer.
 * @param {ColorResolvable} hex The hex code to parse.
 * @returns {number}
 */
export function parseColor(hex: ColorResolvable): number;

/**
 * Alternative to Node's `path.basename`, removing query string after the extension if it exists.
 * @param {string} path Path to get the basename of
 * @param {string} [ext] File extension to remove
 * @see https://github.com/discordjs/discord.js/blob/master/src/util/Util.js#L483-L493
 */
export function basename(path: string, ext?: string): string;

/**
 * Handles all gateway events for the client.
 * @private
 */
export class DataManager {
  /**
   * The client instance.
   * @type {Client}
   */
  readonly client: Client;
  /**
   * The provided engines.
   * @type {MemoryEngine}
   */
  readonly engine: MemoryEngine;
  /**
   * The event stats.
   * @type {Collection<GatewayEvent, number>}
   */
  stats: Collection<GatewayEvent, number>;
  /**
   * The events to track, if any.
   * @type {Array<GatewayEvent> | "all"}
   */
  track: GatewayEvent[] | "all";
  /**
   * Discord structures that can be cached.
   * @type {Set<DiscordStructure>}
   */
  enabled: Set<DiscordStructure>;
  /**
   * All events that won't be handled.
   * @type {Set<GatewayEvent>}
   */
  disabledEvents: Set<GatewayEvent>;
  /**
   * The options provided to the data manager.
   * @type {DataOptions}
   */
  options: Required<DataOptions>;

  /**
   * Creates a new Handlers instance.
   * @param {Client} client The client instance.
   * @param {DataOptions} [options={}]
   */
  constructor(client: Client, options?: DataOptions);

  /**
   * Initializes the packet handling system.
   */
  init(): Promise<void>;
}

export interface DataOptions {
  /**
   * Options for the default engine.
   */
  engine?: EngineOptions;
  /**
   * Whether caching is enabled.
   */
  enabled?: boolean | Set<DiscordStructure> | DiscordStructure[];
  /**
   * Events that wont be handled.
   */
  disabledEvents?: Set<GatewayEvent> | GatewayEvent[];
  /**
   * Tracks how many times a certain event is received.
   */
  track?: GatewayEvent[] | "all" | boolean;
}

