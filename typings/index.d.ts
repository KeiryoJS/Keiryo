// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@neocord/gateway
//   ../@neocord/rest
//   ../@neocord/utils
//   ../discord-api-types
//   ../url
//   ../util
//   ../stream

import type {
  APIAttachment,
  APIBan,
  APIChannel,
  APIChannelMention,
  APIEmbed,
  APIEmbedAuthor,
  APIEmbedField,
  APIEmbedFooter,
  APIEmbedImage,
  APIEmbedProvider,
  APIEmbedThumbnail,
  APIEmbedVideo,
  APIEmoji,
  APIExtendedInvite,
  APIGuild,
  APIGuildIntegration,
  APIGuildMember,
  APIGuildWelcomeScreen,
  APIGuildWelcomeScreenChannel,
  APIIntegrationAccount,
  APIInvite,
  APIMessage,
  APIOverwrite,
  APIRole,
  APIRoleTags,
  APIUser,
  APIVoiceRegion,
  ChannelType,
  EmbedType,
  GatewayActivity,
  GatewayPresenceClientStatus,
  GatewayPresenceUpdate,
  GatewayVoiceState,
  GuildExplicitContentFilter,
  GuildFeature,
  GuildPremiumTier,
  GuildSystemChannelFlags,
  GuildVerificationLevel,
  IntegrationExpireBehavior,
  InviteTargetUserType,
  MessageFlags,
  MessageType,
  OverwriteType,
  PresenceUpdateStatus,
  RESTGetAPIGuildVanityUrlResult,
  UserFlags,
  UserPremiumType
} from "discord-api-types";
import type {
  BitField,
  BitFieldObject,
  Class,
  Collection,
  DeconstructedSnowflake,
  Emitter,
  Extender,
  snowflake
} from "@neocord/utils";
import type { GatewayEvent, Shard, ShardManager, ShardManagerOptions } from "@neocord/gateway";
import type { API, APIOptions, File, ImageURLOptions, RequestData } from "@neocord/rest";
import type { URL } from "url";
import type * as Util from "util";
import type { Readable } from "stream";

declare global {
  interface Object {
    entries<O extends Record<PropertyKey, unknown>, K extends keyof O>(obj: O): ArrayLike<[ K, O[K] ]>;
    keys<O extends Record<PropertyKey, unknown>, K extends keyof O>(obj: O): K[];
  }
}

export class CategoryChannel extends GuildChannel {
  /**
   * The type of channel this is.
   * @type {ChannelType.GUILD_CATEGORY}
   */
  readonly type = ChannelType.GUILD_CATEGORY;

  /**
   * All channels that are a child of this category.
   * @returns {Collection<string, GuildChannel>}
   */
  get children(): Collection<string, GuildChannel>;
}

export abstract class GuildChannel extends Channel {
  /**
   * The guild that this channel belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * All invites for this channel.
   * @type {ChannelInviteManager}
   */
  readonly invites: ChannelInviteManager;
  /**
   * The permission overwrites that belong to this channel.
   * @type {OverwriteManager}
   */
  overwrites: OverwriteManager;
  /**
   * The name of this channel.
   * @type {string}
   */
  name: string;
  /**
   * The sorting position of this channel.
   * @type {number}
   */
  position: number;
  /**
   * The ID of the parent category.
   * @type {string}
   */
  parentId: string | null;
  /**
   * Whether this channel is deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof GuildChannel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data returned from the api.
   * @param {Guild} [guild] The guild instance.
   */
  constructor(client: Client, data: APIChannel, guild?: Guild);

  /**
   * Get the parent category of this channel.
   * @type {CategoryChannel | null}
   */
  get parent(): CategoryChannel | null;

  /**
   * Whether the current user can view this channel.
   * @type {boolean}
   */
  get viewable(): boolean;

  /**
   * Whether the current user can manage this channel.
   * @type {boolean}
   */
  get manageable(): boolean;

  /**
   * Deletes this guild channel.
   * @param {string} [reason] The reason for deleting this channel.
   * @returns {Promise<Readonly<this>>}
   */
  delete(reason?: string): Promise<Readonly<this>>;

  /**
   * Modifies this channel.
   * @param {EditGuildChannel} data The channel modify options.
   * @param {string} [reason] The reason for updating this channel.
   */
  edit(data: EditGuildChannel, reason?: string): Promise<this>;

  /**
   * Updates this guild channel with data from the API.
   * @param {APIChannel} data
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export interface EditGuildChannel extends Dictionary {
  name?: string;
  position?: number | null;
  permissionOverwrites?: (PermissionOverwrite | APIOverwrite)[] | null;
  parent?: CategoryChannel | string;
}

export class NewsChannel extends TextChannel {
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_NEWS}
   */
  readonly type = ChannelType.GUILD_NEWS;

  /**
   * Subscribes a channel to cross-post messages from this channel.
   * @param {string | TextChannel} channel The channel to cross-post to.
   * @returns {FollowedChannel} The follow result.
   */
  follow(channel: string | TextChannel): Promise<FollowedChannel>;

  /**
   * Cross-posts a message in this channel.
   * @param {string | Message} message The message to crosspost.
   * @returns {Promise<Message>} The cross-posted message.
   */
  crosspost(message: string | Message): Promise<Message>;
}

export interface FollowedChannel {
  channelId: string;
  webhookId: string;
}

export class StoreChannel extends GuildChannel {
  readonly structureType = DiscordStructure.GuildChannel;
  /**
   * The type of channel.
   * @type {ChannelType.GUILD_STORE}
   */
  readonly type = ChannelType.GUILD_STORE;
}

export class TextChannel extends GuildChannel {
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_TEXT}
   */
  readonly type: ChannelType;
  /**
   * The typing helper for this channel.
   * @type {TypingManager}
   */
  readonly typing: TypingManager;
  /**
   * The message manager for this channel.
   * @type {MessageManager}
   */
  readonly messages: MessageManager;
  /**
   * The pinned message manager for this channel.
   * @type {PinnedMessageManager}
   */
  readonly pins: PinnedMessageManager;
  /**
   * Amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission ManageMessages or ManageChannel, are unaffected.
   * Or null if there isn't a configured ratelimit.
   * @type {number}
   */
  ratelimit: number | null;
  /**
   * Whether this channel is not safe for work.
   * @type {boolean}
   */
  nsfw: boolean;
  /**
   * The channel topic.
   * @type {string}
   */
  topic: string | null;
  /**
   * The last message that was sent in this channel.
   * @type {string}
   */
  lastMessageId: snowflake | null;
  /**
   * The last message to be pinned in this channel.
   * @type {number | null}
   */
  lastPinTimestamp: number | null;

  /**
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from discord.
   * @param {Guild} guild The guild instance.
   */
  constructor(client: Client, data: APIChannel, guild: Guild);

  /**
   * Whether the current user can attach files in this channel.
   * @type {boolean}
   */
  get attachable(): boolean;

  /**
   * If the current user can send messages in this channel.
   * @type {boolean}
   */
  get postable(): boolean;

  /**
   * If the current user can embed links in this channel.
   * @type {boolean}
   */
  get embeddable(): boolean;

  /**
   * If the current user can view this channel.
   * @type {boolean}
   */
  get viewable(): boolean;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  send(builder: Builder | MessageBuilder): Promise<Message[]>;
  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  send(options: MessageOptions): Promise<Message[]>;
  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  send(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Modifies this text channel.
   * @param {EditGuildChannel} data The data to modify the channel with.
   * @param {string} [reason] The reason to provide.
   */
  edit(data: EditTextChannel, reason?: string): Promise<this>;

  /**
   * Updates this text channel with data from Discord.
   * @param {APIChannel} data
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export interface EditTextChannel extends EditGuildChannel {
  userRatelimit?: number | string | null;
  type?: ChannelType.GUILD_TEXT | ChannelType.GUILD_NEWS;
  topic?: string | null;
  nsfw?: boolean;
}

export class VoiceChannel extends GuildChannel {
  readonly structureType = DiscordStructure.GuildChannel;
  /**
   * The type of this channel.
   * @type {ChannelType.GUILD_VOICE}
   */
  readonly type = ChannelType.GUILD_VOICE;
  /**
   * The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers).
   * @type {number}
   */
  bitrate: number;
  /**
   * The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit.
   * @type {number}
   */
  userLimit: number;

  /**
   * Whether the current user can delete this voice channel.
   * @type {boolean}
   */
  get deletable(): boolean;

  /**
   * Whether the current user can join this channel.
   * @type {boolean}
   */
  get joinable(): boolean;

  /**
   * Whether the current user can speak in this channel.
   * @type {boolean}
   */
  get speakable(): boolean;

  /**
   * Whether the current user can manage this voice channel.
   * @type {boolean}
   */
  get manageable(): boolean;

  /**
   * The members that are in this voice channel.
   * @type {Collection<string, Member>}
   */
  get members(): Collection<string, Member>;

  /**
   * Whether this voice channel has reached the max amount of connected members.
   * @type {boolean}
   */
  get full(): boolean;

  /**
   * Disconnects a member from this voice channel.
   * @param {MemberResolvable} member The member to disconnect.
   * @param {string} [reason] Reason for disconnecting this member.
   * @returns {Promise<Member>} The disconnected member.
   */
  kick(member: MemberResolvable, reason?: string): Promise<Member>;

  /**
   * Edits this voice channel.
   * @param {EditVoiceChannel} data The new properties for the voice channel.
   */
  edit(data: EditVoiceChannel): Promise<this>;
}

export interface EditVoiceChannel extends EditGuildChannel {
  /**
   * The bitrate (in bits) of the voice channel; 8000 to 96000 (128000 for VIP servers)
   * @type {number}
   */
  bitrate?: number;
  /**
   * The user limit of the voice channel; 0 refers to no limit, 1 to 99 refers to a user limit
   * @type {number}
   */
  userLimit?: number;
}

export abstract class Channel extends SnowflakeBase {
  /**
   * The ID of this channel.
   * @type {string}
   */
  readonly id: string;
  /**
   * The typeof channel this is.
   * @type {ChannelType}
   */
  abstract readonly type: ChannelType;
  /**
   * Whether this channel has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Channel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from the api.
   */
  constructor(client: Client, data: APIChannel);

  /**
   * The REST api endpoint for this channel.
   * @type {string}
   */
  get endpoint(): string;

  /**
   * Creates a new channel.
   * @param {Client} client The client instance.
   * @param {APIChannel} data The channel data from discord.
   * @param {...*} args The arguments to pass.
   */
  static create<T extends Channel>(client: Client, data: APIChannel, ...args: any[]): T | null;

  /**
   * Check whether a channel is in a guild..
   * @param {DiscordChannel} channel The channel to check
   * @returns {boolean} Whether the channel is in a guild or not.
   */
  static isGuildBased(channel: Channel): channel is GuildBasedChannel;

  /**
   * Check whether a channel is textable.
   * @param {DiscordChannel} channel The channel to check
   * @returns {boolean} Whether the channel is textable or not.
   */
  static isTextable(channel: Channel): channel is TextBasedChannel;
}

export type TextBasedChannel = DMChannel | TextChannel | NewsChannel;
export type GuildBasedChannel = TextChannel | NewsChannel | StoreChannel | CategoryChannel | VoiceChannel;
export type DiscordChannel = GuildBasedChannel | DMChannel;

export class DMChannel extends Channel {
  readonly structureType = DiscordStructure.DMChannel;
  /**
   * The type of this channel.
   * @type {ChannelType.DM}
   */
  readonly type = ChannelType.DM;
  /**
   * The recipients of this DM.
   * @type {Array<User>}
   */
  recipients: User[];
  /**
   * Whether this DM channel has been deleted.
   * @type {boolean}
   */
  deleted: boolean;
  /**
   * The typing helper for this channel.
   * @type {TypingManager}
   */
  readonly typing: TypingManager;
  /**
   * The message manager for this channel.
   * @type {MessageManager}
   */
  readonly messages: MessageManager;
  /**
   * The pinned message manager for this channel.
   * @type {PinnedMessageManager}
   */
  readonly pins: PinnedMessageManager;
  /**
   * The last message that was sent in this channel.
   * @type {string}
   */
  lastMessageId: snowflake | null;
  /**
   * The last message to be pinned in this channel.
   * @type {number | null}
   */
  lastPinTimestamp: number | null;

  /**
   * @param {Client} client The client instance.
   * @param {APIChannel} data The data from discord.
   */
  constructor(client: Client, data: APIChannel);

  /**
   * Whether the current user can attach files in this channel.
   * @type {boolean}
   */
  get attachable(): boolean;

  /**
   * If the current user can send messages in this channel.
   * @type {boolean}
   */
  get postable(): boolean;

  /**
   * If the current user can embed links in this channel.
   * @type {boolean}
   */
  get embeddable(): boolean;

  /**
   * If the current user can view this channel.
   * @type {boolean}
   */
  get viewable(): boolean;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  send(builder: Builder | MessageBuilder): Promise<Message[]>;
  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  send(options: MessageOptions): Promise<Message[]>;
  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  send(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Closes this DM.
   * @returns {DMChannel}
   */
  close(): Promise<DMChannel>;

  /**
   * Updates this dm channel with data from discord.
   * @protected
   */
  protected _patch(data: APIChannel): this;
}

export class TypingManager {
  /**
   * Creates a new instanceof Typing.
   * @param {TextBasedChannel} channel The channel instance.
   */
  constructor(channel: TextBasedChannel);

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * Increases the interval count and starts typing if not already.
   * @param {number} [count=1] How much to increase the interval count.
   * @returns {Promise<Typing>} This instanceof Typing.
   */
  start(count?: number): Promise<this>;

  /**
   * Decreases the interval count and stops typing if the count is 0 or lower.
   * @param {number} [count=1] How much to decrease the interval count.
   * @returns {Typing} This instanceof Typing.
   */
  stop(count?: number): this;

  /**
   * Forces the typing count to 0 and stops typing.
   * @returns {Typing} This instanceof Typing.
   */
  forceStop(): this;

  /**
   * Starts the typing interval if not already started.
   * @returns {Promise<void>} Nothing...
   */
  protected _start(): Promise<void>;

  /**
   * Stops the typing interval if not already stopped.
   * @returns {void} Nothing...
   */
  protected _stop(): void;

  /**
   * Triggers the typing indicator in the channel.
   * @returns {Promise<void>} Nothing...
   */
  protected _send(): Promise<void>;
}

export class BaseGuildEmoji extends Emoji {
  /**
   * The ID of this emoji.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild that this emoji belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * Whether this emoji must be wrapped in colons
   * @type {?boolean}
   */
  requireColons?: boolean;
  /**
   * Whether this emoji is managed.
   * @type {?boolean}
   */
  managed?: boolean;
  /**
   * Whether this emoji can be used, may be false due to loss of Server Boosts
   * @type {?boolean}
   */
  available?: boolean;
  /**
   * Roles this emoji is whitelisted to.
   * @type {?Array<string>}
   * @protected
   */
  protected _roles?: string[];

  /**
   *
   * @param {Client} client
   * @param {APIEmoji} data
   * @param {Guild} guild
   */
  constructor(client: Client, data: APIEmoji, guild: Guild);

  /**
   * Updates this role with data from discord.
   * @protected
   */
  protected _patch(data: APIEmoji): this;
}

export class GuildEmoji extends BaseGuildEmoji {
  /**
   * The member that created this guild emoji.
   * @type {Member}
   */
  author?: Member;

  /**
   * Roles this emoji is whitelisted to.
   * @type {Collection<string, Role>}
   */
  get roles(): Collection<string, Role>;

  /**
   * Updates this guild emoji with data from discord.
   * @protected
   */
  protected _patch(data: APIEmoji): this;
}

export class GuildPreviewEmoji extends BaseGuildEmoji {
}

export class WelcomeChannel {
  /**
   * The welcome screen.
   * @type {WelcomeScreen}
   */
  readonly welcomeScreen: WelcomeScreen;
  /**
   * The ID of the channel this welcome channel belongs to.
   * @type {string}
   */
  channelId: string;
  /**
   * The ID of the emoji used.
   * @type {string | null}
   */
  emojiId: string | null;
  /**
   * The name of the emoji used.
   * @type {string | null}
   */
  emojiName: string | null;

  /**
   * Creates a new instanceof WelcomeChannel.
   * @param {WelcomeScreen} welcomeScreen The welcome screen.
   * @param {APIGuildWelcomeScreenChannel} data The welcome channel data.
   */
  constructor(welcomeScreen: WelcomeScreen, data: APIGuildWelcomeScreenChannel);

  /**
   * The guild this welcome channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * The channel instance.
   * @type {TextChannel}
   */
  get channel(): TextBasedChannel;
}

export class WelcomeScreen {
  /**
   * The guild this welcome screen belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The description of the server.
   * @type {string | null}
   */
  description: string | null;
  /**
   * Configured welcome screen channels.
   * @type {Collection<string, WelcomeChannel>}
   */
  welcomeChannels: Collection<string, WelcomeChannel>;

  /**
   * Creates a new instanceof WelcomeScreen.
   * @param {Guild} guild The guild that this welcome screen belongs to.
   * @param {APIGuildWelcomeScreen} data The welcome screen data from the api.
   */
  constructor(guild: Guild, data: APIGuildWelcomeScreen);

  /**
   * Updates this instance with data from the api.
   * @param {APIGuildWelcomeScreen} data
   * @protected
   */
  protected _patch(data: APIGuildWelcomeScreen): this;
}

export class Ban extends SnowflakeBase {
  /**
   * ID of the banned user.
   * @type {string}
   */
  readonly id: string;
  /**
   * The reason for the ban.
   * @type {string | null}
   */
  readonly reason: string | null;
  /**
   * The guild the ban belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * Whether this ban has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * @param {Client} client The client instance.
   * @param {APIBan} data The ban data from discord.
   * @param {Guild} guild The guild instance.
   */
  constructor(client: Client, data: APIBan, guild: Guild);

  /**
   * The user that this ban is for.
   * @type {User}
   */
  get user(): User | null;

  /**
   * Deletes this ban. (unban's the user)
   * @param {string} [reason] Reason for unbanning the user.
   * @returns {Ban}
   */
  delete(reason: string): Promise<this>;
}

export class Guild extends Base {
  /**
   * The ID of this guild.
   * @type {string}
   */
  readonly id: string;
  /**
   * All cached roles for this guild.
   * @type {RoleManager}
   */
  readonly roles: RoleManager;
  /**
   * All presences for this guild.
   * @type {PresenceManager}
   */
  readonly presences: PresenceManager;
  /**
   * All cached voice states for this guild.
   * @type {VoiceStateManager}
   */
  readonly voiceStates: VoiceStateManager;
  /**
   * The integrations manager for this guild.
   * @type {GuildIntegrationManager}
   */
  readonly integrations: GuildIntegrationManager;
  /**
   * All cached channels for this guild.
   * @type {GuildChannelManager}
   */
  readonly channels: GuildChannelManager;
  /**
   * All cached members for this guild.
   * @type {MemberManager}
   */
  readonly members: MemberManager;
  /**
   * All cached bans for this guild.
   * @type {BanManager}
   */
  readonly bans: BanManager;
  /**
   * Whether this guild has been deleted from the cache.
   * @type {boolean}
   */
  deleted: boolean;
  /**
   * The name of this guild.
   * @type {string}
   */
  name: string;
  /**
   * The ID of the AFK Voice Channel.
   * @type {string | null}
   */
  afkChannelId: string | null;
  /**
   * AFK Timeout in seconds.
   * @type {number | null}
   */
  afkTimeout: number | null;
  /**
   * Approximate number of members in this guild.
   * @type {number | null}
   */
  approximateMemberCount: number | null;
  /**
   * Approximate number of non-offline members in this guild.
   * @type {number | null}
   */
  approximatePresenceCount: number | null;
  /**
   * The hash of the guild banner,
   * @type {string | null}
   */
  banner: string | null;
  /**
   * The description of this guild, if the guild is discoverable.
   * @type {string | null}
   */
  description: string | null;
  /**
   * The discovery splash hash, only for guilds that are discoverable.
   * @type {string | null}
   */
  discoverySplash: string | null;
  /**
   * The explicit content filter config.
   * @type {GuildExplicitContentFilter}
   */
  contentFilter: GuildExplicitContentFilter;
  /**
   * Enabled guild features.
   * @type {GuildFeature[]}
   */
  features: GuildFeature[];
  /**
   * Timestamp for when the client joined the guild.
   * @type {number | null}
   */
  joinedTimestamp: number | null;
  /**
   * Whether this guild is considered a large guild.
   * @type {boolean}
   */
  large: boolean;
  /**
   * The maximum number of members allowed in this guild.
   * @type {number}
   */
  maxMembers?: number;
  /**
   * The maximum number of presences for this guild.
   * @type {number}
   */
  maxPresences?: number;
  /**
   * The maximum amount of users in a video channel
   * @type {number | null}
   */
  maxVideoChannelUsers: number | null;
  /**
   * Total number of members in this guild
   * @type {number | null}
   */
  memberCount: number | null;
  /**
   * The ID of the user who owns this guild.
   * @type {string}
   */
  ownerId: string;
  /**
   * The preferred locale of a guild with the PUBLIC feature, defaults to "en-US".
   * @type {string}
   */
  preferredLocale: string;
  /**
   * The number of boosts this guild currently has.
   * @type {number}
   */
  boostCount: number;
  /**
   * The current boost tier of this guild.
   * @type {GuildPremiumTier}
   */
  boostTier: GuildPremiumTier;
  /**
   * The ID of the channel where admins/moderators of guilds with the PUBLIC feature will receives notices from Discord.
   * @type {string | null}
   */
  updatesChannelId: string | null;
  /**
   * The voice region of this guild.
   * @type {string}
   */
  region: string;
  /**
   * The ID of the channel where guilds with the PUBLIC feature can display rules and/or guidelines.
   * @type {string | null}
   */
  rulesChannelId: string | null;
  /**
   * System channel flags.
   * @type {GuildSystemChannelFlags}
   */
  systemChannelFlags: GuildSystemChannelFlags;
  /**
   * The id of the channel where guild notices such as welcome messages and boost events are posted.
   * @type {string | null}
   */
  systemChannelId: string | null;
  /**
   * The vanity invite code for this server.
   * @type {string | null}
   */
  vanityURLCode: string | null;
  /**
   * Verification level required for this guild.
   * @type {GuildVerificationLevel}
   */
  verificationLevel: GuildVerificationLevel;
  /**
   * The icon hash.
   * @type {string | null}
   */
  icon: string | null;
  /**
   * The welcome screen, only for community servers.
   * @type {WelcomeScreen}
   */
  welcomeScreen?: WelcomeScreen;
  /**
   * Whether this guild is unavailable or not.
   * @type {boolean}
   */
  unavailable: boolean;

  /**
   * Creates a new instance of Guild.
   * @param {Client} client
   * @param {APIGuild} data
   */
  constructor(client: Client, data: APIGuild);

  /**
   * The shard that this guild belongs to.
   * @type {Shard}
   */
  get shard(): Shard;

  /**
   * The client as a member of this guild.
   * @type {Member}
   */
  get me(): Member;

  /**
   * Get the icon URL of this guild.
   * @param {ImageURLOptions} [options] The URL options.
   * @returns {?string} Returns the URL of the guild icon, if any.
   */
  iconURL(options?: ImageURLOptions): string | null;

  /**
   * Make the current user leave this guild.
   * @returns {Promise<Guild>} This guild.
   */
  leave(): Promise<Readonly<Guild>>;

  /**
   * The list of voice regions for this guild.
   * @returns {Promise<VoiceRegion[]>} The voice regions for this guild.
   */
  fetchRegions(): Promise<VoiceRegion[]>;

  /**
   * Fetches this guilds vanity url if it's enabled.
   * @returns {Promise<RESTGetAPIGuildVanityUrlResult>} This guilds vanity url.
   */
  fetchVanityUrl(): Promise<RESTGetAPIGuildVanityUrlResult>;

  /**
   * Deletes this guild. Current user must be the owner.
   * @returns {Promise<Readonly<Guild>>} This guild.
   */
  delete(): Promise<Readonly<Guild>>;

  /**
   * The string representation of this guild.
   * @returns {string} The name of the guild.
   */
  toString(): string;

  /**
   * Updates this guild with data from the api.
   * @protected
   */
  protected _patch(data: APIGuild): this;
}

export class Member extends Base {
  /**
   * The ID of this member.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild this member belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The roles that belong to this member.
   * @type {MemberRoleManager}
   */
  readonly roles: MemberRoleManager;
  /**
   * This users guild nickname.
   * @type {string | null}
   */
  nickname: string | null;
  /**
   * When the user joined the guild.
   * @type {number}
   */
  joinedTimestamp: number;
  /**
   * When the user started boosting the guild.
   * @type {number | null}
   */
  boostedTimestamp: number | null;
  /**
   * Whether the user is muted in voice channels.
   * @type {boolean}
   */
  deaf: boolean;
  /**
   * Whether the user is deafened in voice channels.
   * @type {boolean}
   */
  mute: boolean;
  /**
   * Whether this member has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Member
   * @param {Client} client
   * @param {APIGuildMember} data
   * @param {string} guild The guild that this role belongs to.
   */
  constructor(client: Client, data: APIGuildMember, guild: Guild);

  /**
   * The presence of this member.
   * @type {Presence | null}
   */
  get presence(): Presence | null;

  /**
   * The user that this guild member represents.
   * @type {User}
   */
  get user(): User;

  /**
   * The calculated permissions from the member's roles.
   * @type {Permissions}
   */
  get permissions(): Permissions;

  /**
   * The displayed name for this guild member.
   * @type {string}
   */
  get displayName(): string;

  /**
   * The {@link VoiceState voice state} of this member.
   * @type {VoiceState | null}
   */
  get voice(): VoiceState | null;

  /**
   * The mention string for this member.
   * @type {string}
   */
  get mention(): string;

  /**
   * Whether the current user can ban this member.
   * @type {boolean}
   */
  get bannable(): boolean;

  /**
   * Whether the current user can ban this member.
   * @type {boolean}
   */
  get kickable(): boolean;

  /**
   * Whether the current user can manage this member.
   * @type {boolean}
   */
  get manageable(): boolean;

  /**
   * The string representation of this member.
   * @type {string}
   */
  toString(): string;

  /**
   * Checks permissions for this member in a given channel.
   * @param {GuildChannel} channel The guild channel.
   * @param {boolean} [guildScope]
   * @type {Readonly<Permissions>}
   */
  permissionsIn(channel: GuildChannel, guildScope?: boolean): Readonly<Permissions>;

  /**
   * Kicks this member from the {@link Guild guild}.
   * @param {string} [reason] The audit-log reason.
   * @returns {Promise<Member>}
   */
  kick(reason?: string): Promise<Readonly<Member>>;

  /**
   * Bans this member from the {@link Guild guild}.
   * @param {BanOptions} [options] The options for the {@link Ban ban}.
   * @returns {Promise<Member>}
   */
  ban(options?: BanOptions): Promise<Readonly<Member>>;

  /**
   * Edits this member
   * @param {MemberUpdateData} data The data to update the member with.
   * @param {string} [reason] The reason for editing this member.
   * @returns {Promise<this>}
   */
  edit(data: MemberUpdateData, reason?: string): Promise<this>;

  /**
   * Fetches this member from the api.
   * @param {boolean} [force] Whether to skip the cache check.
   * @returns {Promise<Member>}
   */
  fetch(force?: boolean): Promise<Member>;

  /**
   * Updates this guild member from the discord gateway/api.
   * @param {APIGuildMember} data
   * @protected
   */
  protected _patch(data: APIGuildMember): this;
}

export interface MemberUpdateData {
  /**
   * Array of roles the member is assigned.
   * @type {RoleResolvable[]}
   */
  roles?: RoleResolvable[];
  /**
   * Value to set users nickname to.
   * @type {?string}
   */
  nick?: string | null;
  /**
   * Whether the user is deafened in voice channels.
   * @type {boolean}
   */
  deaf?: boolean;
  /**
   * Whether the user is muted in voice channels.
   * @type {boolean}
   */
  mute?: boolean;
  /**
   * ID of channel to move user to (if they are connected to voice)
   * @type {BaseResolvable<VoiceChannel>}
   */
  channel?: BaseResolvable<VoiceChannel> | null;
}

export class PermissionOverwrite extends Base {
  /**
   * The role or user ID.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild channel that this permission overwrite belongs to.
   * @type {GuildChannel}
   */
  readonly channel: GuildChannel;
  /**
   * Either "role" or "member"
   * @type {OverwriteType}
   */
  readonly type: OverwriteType;
  /**
   * The permissions this overwrite denies.
   * @type {Readonly<Permissions>}
   */
  deny: Readonly<Permissions>;
  /**
   * The permissions this overwrite allows.
   * @type {Readonly<Permissions>}
   */
  allow: Readonly<Permissions>;
  /**
   * Whether this permission overwrite has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof PermissionOverwrite.
   * @param {Client} client The client instance.
   * @param {APIOverwrite} data The overwrite data from discord.
   * @param {GuildChannel} channel The guild channel that this permission overwrite belongs to.
   */
  constructor(client: Client, data: APIOverwrite, channel: GuildChannel);

  /**
   * Resolves an overwrite into an object.
   * @param {PermissionOverwrite | APIOverwrite} overwrite The permission overwrite instance.
   * @param {Guild} guild The guild instance.
   * @returns {APIOverwrite} The resolved overwrite.
   */
  static resolve(overwrite: PermissionOverwrite | APIOverwrite, guild: Guild): APIOverwrite;

  /**
   * Update this permission overwrite
   * @param {Record<Permission, boolean | null>} options The options for the update.
   * @param {string} [reason] Reason for creating/editing this overwrite.
   * @returns {PermissionOverwrite}
   */
  edit(options: Record<Permission, boolean | null>, reason?: string): Promise<PermissionOverwrite>;

  /**
   * The JSON representation of this overwrite.
   * @returns {APIOverwrite}
   */
  toJSON(): APIOverwrite;

  /**
   * Updates this permission overwrite with data from discord.
   * @protected
   */
  protected _patch(data: APIOverwrite): this;
}

export class Presence extends Base {
  /**
   * The id of the member this presence corresponds to.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild instance.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The member's status.
   * @type {PresenceUpdateStatus}
   */
  status: PresenceUpdateStatus;
  /**
   * The member's platform-dependant status.
   * @type {GatewayPresenceClientStatus}
   */
  clientStatus: GatewayPresenceClientStatus;
  /**
   * The member's current activities.
   * @type {Array<GatewayActivity>}
   */
  activities: GatewayActivity[];

  /**
   * Creates a new instanceof Presence.
   * @param {Client} client The client instance.
   * @param {GatewayPresenceUpdate} data The presence update.
   * @param {Guild} [guild] The guild instance.
   */
  constructor(client: Client, data: GatewayPresenceUpdate, guild?: Guild);

  /**
   * The guild member that this presence belongs to.
   * @type {Member}
   */
  get member(): Member;

  /**
   * Updates this presence with from the gateway.
   * @param {GatewayPresenceUpdate} data
   * @protected
   */
  protected _patch(data: GatewayPresenceUpdate): this;
}

/**
 * Represents a Discord Role.
 * @extends {SnowflakeBase}
 */
export class Role extends SnowflakeBase {
  /**
   * The ID of this role.
   * @type {string}
   */
  readonly id: string;
  /**
   * The {@link Guild guild} this role belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * The color that this role has.
   * @type {number}
   */
  color: number;
  /**
   * If this role is pinned in the user listing
   * @type {boolean}
   */
  hoisted: boolean;
  /**
   * Whether this role is managed by an integration
   * @type {boolean}
   */
  managed: boolean;
  /**
   * Whether this role is mentionable
   * @type {boolean}
   */
  mentionable: boolean;
  /**
   * The name of this role.
   * @type {string}
   */
  name: string;
  /**
   * The permissions of this role.
   * @type {Permissions}
   */
  permissions: Permissions;
  /**
   * The position of this role
   * @type {number}
   */
  position: number;
  /**
   * Tags for this role.
   * @type {APIRoleTags}
   */
  tags: APIRoleTags | null;
  /**
   * Whether this role has been deleted or not.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instanceof Role.
   * @param {Client} client The client instance.
   * @param {APIRole} data Data sent from the Discord API.
   * @param {Guild} guild The guild that this role belongs to.
   */
  constructor(client: Client, data: APIRole, guild: Guild);

  /**
   * Whether or not this role is @everyone
   * @type {boolean}
   */
  get everyone(): boolean;

  /**
   * All of the guild members that have this role.
   * @type {Collection<string, Member>}
   */
  get members(): Collection<string, Member>;

  /**
   * The mention string of this role.
   * @type {string}
   */
  get mention(): string;

  /**
   * The string representation of this role.
   * @type {string}
   */
  toString(): string;

  /**
   * Deletes the role from the guild.
   * @param {string} [reason]
   */
  delete(reason?: string): Promise<this>;

  /**
   * Modifies this guild role.
   * @param {ModifyRoleData} data The data to update this role with.
   * @param {string} [reason]
   */
  edit(data: ModifyRoleData, reason?: string): Promise<this>;

  /**
   * Add this role to a guild member.
   * @param {MemberResolvable} target The target member.
   * @param {string} [reason] The reason for adding the role.
   */
  addTo(target: MemberResolvable, reason?: string): Promise<this>;

  /**
   * Remove this role to a guild member.
   * @param {MemberResolvable} target The target member.
   * @param {string} [reason] The reason for removing the role.
   */
  removeFrom(target: MemberResolvable, reason?: string): Promise<this>;

  /**
   * Checks permissions for this member in a given channel.
   * @param {GuildChannel} channel The channel to check permissions in.
   * @param {boolean} [guildScope] Whether to take into account guild scoped permissions, or just overwrites.
   * @returns {Permissions}
   */
  permissionsIn(channel: GuildChannel, guildScope?: boolean): Readonly<Permissions>;

  /**
   * Updates this role with data from the api.
   * @protected
   */
  protected _patch(data: APIRole): this;
}

/**
 * @interface
 */
export interface ModifyRoleData {
  /**
   * Name of the role.
   */
  name?: string | null;
  /**
   * Permissions to give this role.
   */
  permissions?: PermissionResolvable | null;
  /**
   * RGB color value or hex code.
   */
  color?: number | string | null;
  /**
   * Whether the role should be displayed separately in the sidebar.
   */
  hoist?: boolean | null;
  /**
   * Whether the role should be mentionable.
   */
  mentionable?: boolean | null;
}

export class VoiceState extends Base {
  /**
   * The ID of the user the voice state is for.
   * @type {string}
   */
  readonly id: string;
  /**
   * The guild this voice state is apart of.
   * @type {Guild}
   */
  readonly guild: Guild;
  /**
   * ID of the channel the user is in.
   * @type {string | null}
   */
  channelId: string | null;
  /**
   * The voice state's session id.
   * @type {string}
   */
  sessionId: string;
  /**
   * Whether this user is deafened by the server.
   * @type {boolean}
   */
  serverDeafened: boolean;
  /**
   * Whether this user is muted by the server.
   * @type {boolean}
   */
  serverMuted: boolean;
  /**
   * Whether this user is locally deafened.
   * @type {boolean}
   */
  selfDeafened: boolean;
  /**
   * Whether this user is locally muted.
   * @type {boolean}
   */
  selfMuted: boolean;
  /**
   * Whether this user is streaming using "Go Live"
   * @type {boolean}
   */
  selfStream: boolean;
  /**
   * Whether this user's camera is enabled.
   * @type {boolean}
   */
  selfVideo: boolean;
  /**
   * Whether this user is muted by the current user.
   * @type {boolean}
   */
  suppressed: boolean;

  /**
   * Creates a new instanceof VoiceState.
   * @param {Client} client The client instance.
   * @param {GatewayVoiceState} data The voice state data.
   * @param {Guild} guild The guild.
   */
  constructor(client: Client, data: GatewayVoiceState, guild: Guild);

  /**
   * The channel that the user is in.
   * @type {VoiceChannel | null}
   */
  get channel(): VoiceChannel | null;

  /**
   * The member this voice state belongs to.
   * @type {Member}
   */
  get member(): Member;

  /**
   * Whether this member is server-deafened or self-deafened.
   * @type {boolean}
   */
  get deaf(): boolean;

  /**
   * Whether this member is server-muted or self-muted.
   * @type {boolean}
   */
  get mute(): boolean;

  /**
   * (Un)mute the member of this voice state.
   * @param {boolean} [mute=true] Whether or not to mute the member.
   * @param {string} [reason] Reason for (un)muting this member.
   * @returns {Promise<Member>}
   */
  setMute(mute?: boolean, reason?: string): Promise<Member>;

  /**
   * (Un)deafen the member of this voice state.
   * @param {boolean} [deaf=true] Whether or not to deafen this member.
   * @param {string} [reason] The reason for (un)deafening this member.
   * @returns {Promise<Member>}
   */
  setDeaf(deaf?: boolean, reason?: string): Promise<Member>;

  /**
   * Moves the member of this voice state to a different channel, or disconnects them from their current channel.
   * @param {BaseResolvable<VoiceChannel> | null} channel The voice channel to move the member to, or `null` to disconnect them.
   * @param {string} [reason] The reason for moving or disconnecting the member.
   * @returns {Promise<Member>}
   */
  setChannel(channel: BaseResolvable<VoiceChannel> | null, reason?: string): Promise<Member>;

  /**
   * Kicks the member from the channel they are currently in.
   * @param {string} [reason] The reason for disconnecting the member.
   * @returns {Promise<Member>}
   */
  kick(reason?: string): Promise<Member>;

  /**
   * Updates this voice state with data from the discord gateway/api.
   * @protected
   */
  protected _patch(data: GatewayVoiceState): this;
}

export class Integration extends Base {
  /**
   * Integration ID.
   * @type {string}
   */
  readonly id: string;
  /**
   * Integration name.
   * @type {string}
   */
  readonly name: string;
  /**
   * Integration type (twitch, youtube, etc)
   * @type {string}
   */
  readonly type: string;
  /**
   * Whether this integration is enabled.
   * @type {boolean}
   */
  readonly enabled: boolean;
  /**
   * Role ID that that this integration uses for "subscribers".
   * @type {string}
   */
  readonly roleId: string;
  /**
   * The user for this integration.
   * @type {string}
   */
  readonly userId: string;
  /**
   * integration account information
   * @type {APIIntegrationAccount}
   */
  readonly account: APIIntegrationAccount;
  /**
   * Whether this integration is currently syncing.
   * @type {boolean}
   */
  syncing: boolean;
  /**
   * When this integration was last synced.
   * @type {number}
   */
  syncedTimestamp: number;
  /**
   * Whether emoticons should be synced for this integration (twitch only currently).
   * @type {boolean}
   */
  enableEmoticons: boolean;
  /**
   * The behavior of expiring subscribers.
   * @type {IntegrationExpireBehavior}
   */
  expireBehavior: IntegrationExpireBehavior;
  /**
   * The grace period (in days) before expiring subscribers.
   * @type {number}
   */
  expireGracePeriod: number;
  /**
   * Whether this integration is deleted.
   * @type {boolean}
   */
  deleted: boolean;


  /**
   * @param {Client} client
   * @param {APIGuildIntegration} data
   * @param {Guild} guild
   */
  constructor(client: Client, data: APIGuildIntegration, guild: Guild);

  /**
   * The guild that this integration belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Role that that this integration uses for "subscribers".
   * @type {?Role}
   */
  get role(): Role | null;

  /**
   * The user for this integration.
   * @type {?User}
   */
  get user(): User | null;

  /**
   * Syncs this integration.
   * @returns {Promise<Integration>}
   */
  sync(): Promise<Integration>;

  /**
   * Edit this integration.
   * @param {EditIntegration} data The data to edit this integration with.
   * @param {string} [reason] Reason for editing this integration.
   * @returns {Promise<Integration>}
   */
  edit(data: EditIntegration, reason?: string): Promise<Integration>;

  /**
   * Updates this integration with data from discord.
   * @param {APIGuildIntegration} data
   * @protected
   */
  protected _patch(data: APIGuildIntegration): this;
}

export interface EditIntegration {
  /**
   * The behavior when an integration subscription lapses (see the integration expire behaviors documentation).
   * @type {IntegrationExpireBehavior}
   */
  expireBehavior?: IntegrationExpireBehavior;
  /**
   * Period (in days) where the integration will ignore lapsed subscriptions.
   * @type {boolean}
   */
  expireGracePeriod?: number;
  /**
   * Whether emoticons should be synced for this integration (twitch only currently).
   * @type {boolean}
   */
  enableEmoticons?: boolean;
}

export class Message extends SnowflakeBase {
  /**
   * The ID of this message.
   * @type {string}
   */
  readonly id: string;
  /**
   * The author of this message.
   * @type {User}
   */
  readonly author: User;
  /**
   * The guild member that sent this message.
   * @type {Member | null}
   */
  readonly member: Member | null;
  /**
   * The channel that this message was sent.
   * @type {TextBasedChannel}
   */
  readonly channel: TextBasedChannel;
  /**
   * Any attached files
   * @type {Collection<string, MessageAttachment>}
   */
  readonly attachments: Collection<string, MessageAttachment>;
  /**
   * The mentions in this message.
   * @type {MessageMentions}
   */
  mentions: MessageMentions;
  /**
   * Whether or not this message was TTS.
   * @type {boolean}
   */
  tts: boolean;
  /**
   * Used for validating whether a message was sent.
   * @type {string | number | null}
   */
  nonce: string | number | null;
  /**
   * The current content of this message.
   * @type {string}
   */
  content: string;
  /**
   * The previous content of this message, always null unless editedTimestamp isn't null.
   * @type {string | null}
   */
  previousContent: string | null;
  /**
   * The timestamp of when this message was edited, or null if it hasn't been edited.
   * @type {number | null}
   */
  editedTimestamp: number | null;
  /**
   * Whether this message is pinned.
   * @type {boolean}
   */
  pinned: boolean;
  /**
   * Embeds that were sent along with this message.
   * @type {Array<Embed>}
   */
  embeds: Embed[];
  /**
   * The type of message.
   * @type {MessageType}
   */
  type: MessageType;
  /**
   * The flags.
   * @type {MessageFlags}
   */
  flags: MessageFlags;
  /**
   * Whether this message has been deleted.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * Creates a new instance of Message.
   * @param {Client} client The client instance.
   * @param {APIMessage} data The decoded message object.
   * @param {TextBasedChannel} channel The channel that this message was sent in.
   */
  constructor(client: Client, data: APIMessage, channel: TextBasedChannel);

  /**
   * The guild that this message was sent in.
   * @type {string}
   */
  get guild(): Guild | null;

  /**
   * The url to jump to this message.
   * @type {string}
   */
  get url(): string;

  /**
   * The date in which this message was edited.
   * @type {Date}
   */
  get editedAt(): Date | null;

  /**
   * Deletes this message from the channel.
   * @param {MessageDeleteOptions} [options] Options for deleting this message.
   * @returns {Message}
   */
  delete(options?: MessageDeleteOptions): Promise<this>;

  /**
   * Pins this message to the channel.
   * @param {string} reason
   */
  pin(reason?: string): Promise<Message>;

  /**
   * Crosspost a message in a news channel to following channels.
   * @returns {Message}
   */
  crosspost(): Promise<Message>;

  /**
   * Edits this message.
   * @param {MessageEditOptions} options The options to use for editing this message.
   */
  edit(options: MessageEditOptions): Promise<Message>;
  /** Edits this message.
   * @param {MessageEditData} content The message edit content.
   * @param {MessageEditOptions} [options] The message edit options.
   */
  edit(content: MessageEditData, options?: MessageEditOptions): Promise<Message>;

  suppressEmbeds(suppress?: boolean): Promise<Message>;

  /**
   * Patches this message with data from the api.
   * @protected
   */
  protected _patch(data: APIMessage): this;
}

export type MessageEditData = string | Embed | MessageEditOptions;

export class MessageAttachment {
  /**
   * The image.
   * @type {ImageResolvable}
   */
  attachment: ImageResolvable;
  /**
   * The name of this attachment.
   * @type {string | null}
   */
  name: string | null;
  /**
   * Attachment id.
   * @type {string}
   */
  id: string;
  /**
   * Size of file in bytes.
   * @type {number}
   */
  size: number;
  /**
   * Source url of file.
   * @type {string}
   */
  url: string;
  /**
   * The proxy url of file.
   * @type {string}
   */
  proxyUrl: string;
  /**
   * Height of file (if image).
   * @type {number | null}
   */
  height: number | null;
  /**
   * Width of file (if image).
   * @type {number | null}
   */
  width: number | null;

  /**
   * @param {ImageResolvable} attachment
   * @param {string} [name=null]
   * @param {APIAttachment} data
   */
  constructor(attachment: ImageResolvable, name: string | null, data: APIAttachment);

  /**
   * Whether or not this attachment has been marked as a spoiler.
   * @type {boolean}
   */
  get spoiler(): boolean;

  /**
   * Set the file of this message attachment
   * @param {ImageResolvable} file The file.
   */
  setFile(file: ImageResolvable): MessageAttachment;

  /**
   * Set the name of this message attachment.
   * @param {string} name The new name of this attachment.
   */
  setName(name: string): MessageAttachment;

  /**
   * Updates this message attachment with data from discord.
   * @protected
   */
  protected _patch(data: APIAttachment): this;
}

export class MessageMentions {
  /**
   * The {@link Message} these mentions belong to.
   * @type {Message}
   */
  readonly message: Message;
  /**
   * Any {@link User users} that mentioned.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, User>}
   */
  users: Collection<string, User>;
  /**
   * Any {@link Role roles} that were mentioned.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, Role>}
   */
  roles: Collection<string, Role>;
  /**
   * A collection of crossposted channels.
   * Order is as received from the API, not as they appear in the message.
   * @type {Collection<string, CrosspostedChannel>}
   */
  crosspostedChannels: Collection<string, CrosspostedChannel>;
  /**
   * Whether `@everyone` or `@here` were mentioned
   * @type {boolean}
   */
  everyone: boolean;

  /**
   * @param {Message} message
   * @param {MentionedUser[]} users
   * @param {boolean} everyone
   * @param {string[]} roles
   * @param {APIChannelMention} crossposted
   */
  constructor(message: Message, users: MentionedUser[], everyone: boolean, roles: string[], crossposted?: APIChannelMention[]);

  /**
   * Any {@link Member members} that were mentioned.
   * @type {Collection<string, Member>}
   */
  get members(): Collection<string, Member>;

  /**
   * Any {@link GuildChannel channels} that were mentioned.
   * @type {Collection<string, GuildChannel>}
   */
  get channels(): Collection<string, GuildChannel>;
}

export type MentionedUser = APIUser & {
  member?: Omit<APIGuildMember, "user">;
};

export interface CrosspostedChannel {
  /**
   * The ID of the mentioned channel.
   */
  channelId: string;
  /**
   * The type of of the channel.
   */
  type: ChannelType;
  /**
   * The name of the channel.
   */
  name: string;
  /**
   * The ID of the guild that has the channel.
   */
  guildId: string;
}

export class ClientUser extends User {
  /**
   * Set the username of the current user.
   * @param {string} username The new username.
   */
  setUsername(username: string): Promise<this>;

  /**
   * Update the current users avatar.
   * @param {ImageResolvable | null} avatar The avatar to update the current one with.
   */
  setAvatar(avatar: ImageResolvable | null): Promise<this>;

  /**
   * Updates the current user.
   * @param {ClientUserUpdate} data The new username or avatar to update the current user with.
   */
  update(data?: ClientUserUpdate): Promise<this>;
}

export interface ClientUserUpdate {
  username?: string;
  avatar?: ImageResolvable | null;
}

export class Typing {
  /**
   * The client instance.
   * @type {Client}
   */
  readonly client: Client;
  /**
   * The channel that the user is typing in.
   * @type {string}
   */
  readonly channelId: string;
  /**
   * The guild that the user is typing in.
   * @type {string}
   */
  readonly guildId?: string;
  /**
   * The user that is typing.
   * @type {string}
   */
  readonly userId: string;
  /**
   * When the user started typing.
   * @type {number}
   */
  readonly startedTimestamp: number;

  /**
   * @param {Client} client The client instance.
   * @param {TypingStartData} data The typing data.
   */
  constructor(client: Client, data: TypingStartData);

  /**
   * The guild that the user is typing in.
   * @type {?Guild}
   */
  get guild(): Guild | null;

  /**
   * The member that is typing.
   * @type {?Member}
   */
  get member(): Member | null;
}

interface TypingStartData {
  channel_id: string;
  guild_id?: string;
  user_id: string;
  timestamp: number;
  member?: APIGuildMember;
}

export class Embed implements APIEmbed {
  /**
   * The embed video
   * @type {APIEmbedVideo}
   */
  readonly video: APIEmbedVideo;
  /**
   * The embed provider.
   * @type {APIEmbedProvider}
   */
  readonly provider: APIEmbedProvider;
  /**
   * The type of embed.
   * @type {EmbedType}
   */
  readonly type: EmbedType;
  /**
   * The title of this embed.
   * @type {string}
   */
  title?: string;
  /**
   * The description of this embed.
   * @type {string}
   */
  description?: string;
  /**
   * The URL of this embed.
   * @type {string}
   */
  url?: string;
  /**
   * The embed timestamp.
   * @type {string}
   */
  timestamp?: string;
  /**
   * The color of this embed.
   * @type {string}
   */
  color?: number;
  /**
   * The embed footer.
   * @type {APIEmbedFooter}
   */
  footer?: APIEmbedFooter;
  /**
   * The embed image.
   * @type {APIEmbedImage}
   */
  image: APIEmbedImage;
  /**
   * The embed thumbnail.
   * @type {APIEmbedThumbnail}
   */
  thumbnail: APIEmbedThumbnail;
  /**
   * The embed author
   * @type {APIEmbedAuthor}
   */
  author: APIEmbedAuthor;
  /**
   * The fields in this embed.
   * @type {Array<APIEmbedField>}
   */
  fields: APIEmbedField[];

  /**
   * Creates a new Embed instance.
   * @param {Embed | APIEmbed} base
   */
  constructor(base?: Embed | APIEmbed);

  /**
   * The embed color as a hex code.
   * @type {string}
   */
  get hex(): string | null;

  /**
   * The accumulated length for the title, description, fields and footer text.
   * @type {number}
   */
  get length(): number;

  /**
   * Set the thumbnail of this embed.
   * @param {string | URL} url The image url.
   * @param {ImageOptions} [options={}] The options for the image.
   */
  setThumbnail(url: StringResolvable | URL, options?: ImageOptions): this;

  /**
   * Adds a new field to this embed.
   * @param {StringResolvable} name The name of the field.
   * @param {StringResolvable | StringResolvable[]} value The field value.
   * @param {boolean} [inline=false] Whether this field is inline with others.
   */
  addField(name: StringResolvable, value: StringResolvable | StringResolvable[], inline?: boolean): Embed;

  /**
   * Adds a new blank field.
   * @param {boolean} [inline=true] Whether this field should be inline with other fields.
   */
  addBlankField(inline?: boolean): Embed;

  /**
   * Set the title of this embed.
   * @param {string} text The title text.
   */
  setTitle(text: StringResolvable): Embed;

  /**
   * Set the color of this embed.
   * @param {ColorResolvable} color The color of this embed.
   */
  setColor(color: ColorResolvable): this;

  /**
   * Set the author of this embed.
   * @param {string} name The author name.
   * @param {AuthorOptions} [opts={}] The author options.
   */
  setAuthor(name: StringResolvable, opts?: AuthorOptions): this;

  /**
   * Set the embed timestamp.
   * @param {number |Date} date The timestamp.
   */
  setTimestamp(date?: number | Date): Embed;

  /**
   * Set the embed footer.
   * @param {string} text Footer text
   * @param {string | URL} icon The URL of footer icon (only supports http(s) and attachments)
   */
  setFooter(text: StringResolvable, icon?: StringResolvable | URL): Embed;

  /**
   * Set the image of this embed.
   * @param {string | URL} url Source URL of image (only supports http(s) and attachments)
   * @param {ImageOptions} [options={}] Options for the image.
   */
  setImage(url: string | URL, options?: ImageOptions): Embed;

  /**
   * Set the description of this embed.
   * @param {string} text The description content.
   */
  setDescription(text: StringResolvable | StringResolvable[]): Embed;
}

export interface StringResolvable {
  toString(): string;
}

export interface AuthorOptions {
  url?: StringResolvable | URL;
  icon?: StringResolvable | URL;
}

export interface ImageOptions {
  height?: number;
  width?: number;
}

export abstract class Emoji extends Base {
  /**
   * The ID of this emoji.
   * @type {string}
   */
  readonly id: string | null;
  /**
   * The name of this emoji.
   * @type {string}
   */
  name: string;
  /**
   * Whether or not this emoji is animated.
   * @type {boolean}
   */
  animated: boolean;
  /**
   * Whether this emoji has been deleted or not.
   * @type {boolean}
   */
  deleted: boolean;

  /**
   * @param {Client} client
   * @param {APIEmoji} data
   */
  constructor(client: Client, data: APIEmoji);

  /**
   * The identifier for this emoji, used for message reactions.
   * @type {string}
   */
  get identifier(): string;

  /**
   * The URL to this emoji. Only if it's a custom emoji.
   * @type {?string}
   */
  get url(): string | null;

  /**
   * The date when this object was created.
   * @type {Date}
   */
  get createdAt(): Date | null;

  /**
   * The time when this object was created.
   * @type {number}
   */
  get createdTimestamp(): number | null;

  /**
   * The string representation of this emoji.
   * @returns {string}
   */
  toString(): string;
}

export class Invite extends Base {
  /**
   * The "ID" of this invite. (the code of the invite)
   * @type {string}
   */
  readonly id: string;
  /**
   * The channel this invite belongs to.
   * @type {Channel}
   */
  readonly channel: GuildChannel;
  /**
   * The guild the channel belongs to. If the channel is in a guild.
   * @type {Guild | null}
   */
  readonly guild: Guild | null;
  /**
   * Duration (in seconds) after which the invite expires
   * @type {number | null}
   */
  maxAge: number | null;
  /**
   * Max number of times this invite can be used
   * @type {number | null}
   */
  maxUses: number | null;
  /**
   * Whether this invite only grants temporary membership
   * @type {boolean | null}
   */
  temporary: boolean;
  /**
   * When this invite was created.
   * @type {number | null}
   */
  createdTimestamp: number | null;
  /**
   * Number of times this invite has been used.
   * @type {number}
   */
  uses: number;
  /**
   * Approximate count of total members
   * @type {number | null}
   */
  approximateMemberCount: number | null;
  /**
   * Approximate count of online members (only present when target_user is set)
   * @type {number | null}
   */
  approximatePresenceCount: number | null;
  /**
   * The user who created the invite
   * @type {User | null}
   */
  inviter: User | null;
  /**
   * The target user for this invite
   * @type {User | null}
   */
  targetUser: User | null;
  /**
   * The type of user target for this invite
   * @type {InviteTargetUserType | null}
   */
  targetUserType: InviteTargetUserType | null;

  /**
   * Creates a new instanceof Invite.
   * @param {Channel} channel The channel this invite belongs to.
   * @param {APIExtendedInvite} data The data returned from the API.
   * @param {Guild} [guild]
   */
  constructor(channel: GuildChannel, data: APIExtendedInvite, guild?: Guild);

  /**
   * The invite code.
   * @type {string}
   */
  get code(): string;

  /**
   * Deletes this invite.
   * @returns {Promise<Readonly<Invite>>}
   */
  delete(): Promise<Readonly<Invite>>;

  /**
   * Updates this invite with data from discord.
   * @param {APIExtendedInvite} data
   * @protected
   */
  protected _patch(data: APIInvite | APIExtendedInvite): this;
}

export class User extends SnowflakeBase {
  /**
   * The ID of this user.
   * @type {string}
   */
  readonly id: string;
  /**
   * The user's avatar hash.
   * @type {string | null}
   */
  avatar: string | null;
  /**
   * Whether the user belongs to an OAuth2 application.
   * @type {boolean}
   */
  bot: boolean;
  /**
   * The user's 4-digit discord-tag.
   * @type {string}
   */
  discriminator: string;
  /**
   * The user's email.
   * @type {string | null}
   */
  email: string | null;
  /**
   * The flags on this user's account.
   * @type {UserFlags}
   */
  flags: UserFlags;
  /**
   * The public flags on this user's account.
   * @type {UserFlags}
   */
  publicFlags: UserFlags;
  /**
   * The type of Nitro subscription on this user's account.
   * @type {UserPremiumType}
   */
  premiumType: UserPremiumType;
  /**
   * The user's chosen language option.
   * @type {string}
   */
  locale: string;
  /**
   * The user's username, not unique across the platform.
   * @type {string}
   */
  username: string;
  /**
   * Whether the user has two factor enabled on their account.
   * @type {boolean}
   */
  mfaEnabled: boolean;
  /**
   * Whether the email on this account has been verified.
   * @type {boolean}
   */
  verified: boolean;
  /**
   * Whether the user is an Official Discord System user (part of the urgent message system).
   * @type {boolean}
   */
  system: boolean;

  /**
   * Creates a new instance of User.
   * @param {Client} client The client.
   * @param {APIUser} data The decoded user data.
   */
  constructor(client: Client, data: APIUser);

  /**
   * The tag of this user.
   * @type {string}
   */
  get tag(): string;

  /**
   * The mention string for this user.
   * @type {string}
   */
  get mention(): string;

  /**
   * The default avatar url for this user.
   * @type {string}
   */
  get defaultAvatarUrl(): string;

  /**
   * The URL for this user's avatar.
   * @param {ImageURLOptions} [options] The options for the url.
   * @returns {string | null}
   */
  avatarURL(options?: ImageURLOptions): string | null;

  /**
   * Gets an existing DM channel or creates one.
   * @returns {DMChannel}
   */
  dm(): Promise<DMChannel>;

  /**
   * The display avatar url for this user.
   * @param {ImageURLOptions} [options] The options for the avatar.
   * @returns {string}
   */
  displayAvatarURL(options?: ImageURLOptions): string;

  /**
   * Get the string representation of this user.
   * @returns {string}
   */
  toString(): string;

  /**
   * Updates this user with data from the api.
   * @param {APIUser} data
   * @protected
   */
  protected _patch(data: APIUser): this;
}

export class VoiceRegion {
  /**
   * Unique ID for the region.
   * @type {string}
   */
  readonly id: string;
  /**
   * Name of the region.
   * @type {string}
   */
  readonly name: string;
  /**
   * True if this is a vip-only server.
   * @type {boolean}
   */
  readonly vip: boolean;
  /**
   * True for a single server that is closest to the current user's client.
   * @type {boolean}
   */
  readonly optimal: boolean;
  /**
   * Whether this is a deprecated voice region (avoid switching to these).
   */
  readonly deprecated: boolean;
  /**
   * Whether this is a custom voice region (used for events/etc).
   * @type {boolean}
   */
  readonly custom: boolean;

  /**
   * @param {APIVoiceRegion} data The voice region data from discord.
   */
  constructor(data: APIVoiceRegion);

  /**
   * Get the json representation of this voice region.
   * @returns {APIVoiceRegion}
   */
  toJSON(): APIVoiceRegion;
}

export class CachingManager extends Emitter {
  /**
   * The limits for each discord structure.
   * @type {Map<DiscordStructure, number>}
   */
  readonly limits: Map<DiscordStructure, number>;
  /**
   * Structures that wont be cached.
   * @type {Set<DiscordStructure>}
   */
  readonly disabled: Set<DiscordStructure>;

  /**
   * @param {Janitor} janitor
   * @param {CachingOptions} [options] The options for this Caching.
   */
  constructor(janitor: Janitor, options?: CachingOptions);

  on(event: "debug", listener: (message: string) => void): this;
  on(event: "error", listener: (error: Error | string) => void): this;

  /**
   * Creates a new cache.
   * @param {DiscordStructure} structure The structure.
   * @returns {Cache}
   */
  new<V extends Base = Base>(structure: DiscordStructure): Cache<V>;
}

export interface CachingOptions {
  /**
   * The limit for each structure.
   * @type {number | Map<DiscordStructure | number>}
   */
  limit?: number | Map<DiscordStructure, number>;
  /**
   * The structures to disable.
   * @type {Set<DiscordStructure> | DiscordStructure[]}
   */
  disabled?: Set<DiscordStructure> | DiscordStructure[];
  /**
   * Whether to remove an item from the cache if the limit has been reached.
   * @type {boolean}
   */
  removeOneOnFull?: boolean;
}

export class Cache<V extends Base> extends Collection<string, Cached<V>> {

  /**
   * @param {Janitor} janitor the janitor.
   * @param {CacheOptions} options The options for this cache.
   */
  constructor(janitor: Janitor, options: CacheOptions);

  /**
   * Adds an item to the cache.
   * @param {string} id The identifier.
   * @param {Cached<*>} data The data that's being cached.
   */
  set(id: string, data: Cached<V> | V): this;
}

export type Cached<V extends Dictionary> = V & {
  cachedAt: number;
};

interface CacheOptions {
  /**
   * The limit for each structure.
   * @type {number}
   */
  limit: number;
  /**
   * Whether to remove an item from the cache if the limit has been reached.
   * @type {boolean}
   */
  removeOneOnFull: boolean;
  /**
   * Whether this cache is disabled.
   * @type {boolean}
   */
  disabled: boolean;
  /**
   * The discord structure that this caches.
   * @type {DiscordStructure}
   */
  structure: DiscordStructure;
}

export class Janitor {
  /**
   * The engine this janitor belongs to.
   * @type {CachingManager}
   */
  readonly client: Client;
  /**
   * The jobs that janitor has.
   * @type {Map<DiscordStructure | string, Job>}
   */
  readonly jobs: Map<DiscordStructure | string, Job>;

  /**
   * @param {Client} client The engine this janitor belongs to.
   * @param {JanitorJobs} jobs The jobs that this janitor has.
   */
  constructor(client: Client, jobs?: JanitorJobs);

  /**
   * Starts the janitor.
   */
  start(): void;
}

export type JanitorJobs = Partial<Record<DiscordStructure | string, typeof Job>>;

export class Job<O extends JobOptions = JobOptions> {
  /**
   * The name of this job.
   * @type {string}
   */
  readonly name: string;
  /**
   * The interval in which this job runs.
   * @type {number}
   */
  readonly interval: number;
  /**
   * The janitor instance.
   * @type {Janitor}
   */
  readonly janitor: Janitor;
  /**
   * The caches this job is for.
   * @type {Set<Cache>}
   */
  caches?: Set<Cache<Base>>;
  /**
   * The current shift of this job.
   * @type {?CurrentShift}
   */
  shift?: CurrentShift;


  /**
   * @param {Janitor} janitor The janitor instance.
   * @param {string} name The name of this job.
   * @param {JobOptions} options Options for the job.
   */
  constructor(janitor: Janitor, name: string, options: O);

  /**
   * Initializes this job.
   * @returns {boolean}
   */
  start(...args: unknown[]): void;

  /**
   * Quits the job (waits for the current shift to end and
   */
  quit(): Promise<void>;

  /**
   * Doe the job.
   * @returns {*}
   */
  do(shift: CurrentShift, ...args: unknown[]): any;
}

export interface JobOptions {
  interval: string | number;
}

export interface CurrentShift {
  startedAt: number;
  id: number;
  promise: Promise<unknown>;
}

export abstract class Jobs {
  /**
   * The default job for all structures.
   * @param {DiscordStructure} structure The structure this job is for.
   * @param {SweeperJobOptions} options The options for this job.
   * @constructor
   */
  static Default({ structure, ...options }: DefaultJobOptions): typeof Job;

  /**
   * An official message job for engines.
   * @param {SweeperJobOptions} options
   * @constructor
   */
  static Message(options: SweeperJobOptions): typeof Job;
}

interface DefaultJobOptions extends SweeperJobOptions {
  structure: DiscordStructure;
}

export interface SweeperJobOptions extends JobOptions {
  lifetime: number | string;
}

export class Client extends Emitter {
  /**
   * All cached guilds for the current session.
   * @type {GuildManager}
   */
  readonly guilds: GuildManager;
  /**
   * All cached users for the current session.
   * @type {UserManager}
   */
  readonly users: UserManager;
  /**
   * All cached channels for the current session.
   * @type {ChannelManager}
   */
  readonly channels: ChannelManager;
  /**
   * All cached DMs for the current session.
   * @type {DMChannelManager}
   */
  readonly dms: DMChannelManager;
  /**
   * The manager for discord invites.
   * @type {InviteManager}
   */
  readonly invites: InviteManager;
  /**
   * The current user.
   * @type {?ClientUser}
   */
  user?: ClientUser;
  /**
   * The token of this client.
   * @type {?string}
   */
  token?: string;
  /**
   * When the client last became ready.
   * @type {?number}
   */
  readyAt?: number;

  /**
   * Creates a new Client.
   * @param {ClientOptions} options The options.
   */
  constructor(options?: ClientOptions);

  /**
   * The shard manager for this client.
   * @type {ShardManager}
   */
  get ws(): ShardManager;

  /**
   * The interface for the discord api and cdn.
   * @type {API}
   */
  get api(): API;

  /**
   * The data manager for this client.
   * @type {DataManager}
   */
  get data(): DataManager;

  /**
   * How long it has been since the client last became ready.
   * @type {?number}
   */
  get uptime(): number | null;

  /**
   * Connects the bot to the discord gateway.
   * @param {string} [token] The bot token.
   * @returns {Promise<Client>}
   */
  connect(token?: string): Promise<this>;

  /**
   * Destroys this client.
   * @returns {void}
   */
  destroy(): void;

  /**
   * Listen for a client event.
   * @param {string} event The event to listen for.
   * @param {Function} listener The event listener.
   */
  on<K extends keyof ClientEvents>(event: K, listener: ClientEvents[K]): this;
}

export type ClientEvents = {
  messageCreate: (message: Message) => void;
  messageUpdate: (old: Readonly<Message>, updated: Message) => void;
  debug: (message: string) => void;
  error: (error: any, message: string | undefined) => void;
} & Record<"ready" | string, (...args: any[]) => void>;

export interface ClientOptions {
  /**
   * Options for the sharding manager.
   */
  ws?: ShardManagerOptions;
  /**
   * Options for the REST manager.
   */
  rest?: APIOptions;
  /**
   * Options for data.
   */
  data?: DataOptions;
}

export class MessageManager extends BaseManager<Message> {
  /**
   * The text channel.
   */
  readonly channel: TextBasedChannel;

  /**
   * Creates a new instanceof MessageManager.
   * @param {TextBasedChannel} channel The text channel instance.
   */
  constructor(channel: TextBasedChannel);

  /**
   * Deletes a message from the channel.
   * @param {string} message The message to delete.
   * @param {MessageDeleteOptions} options The delete options.
   * @returns {Message} The deleted message.
   */
  remove(message: MessageResolvable, options?: MessageDeleteOptions): Promise<Message | null>;

  /**
   * Creates a new message.
   * @param {Builder} builder The message builder.
   * @returns {Promise<Message[]>} The created messages.
   */
  new(builder: Builder | MessageBuilder): Promise<Message[]>;
  /**
   * Creates a new message.
   * @param {MessageOptions} options The message options.
   */
  new(options: MessageOptions): Promise<Message[]>;
  /**
   * Creates a new message in this channel.
   * @param {MessageAdd} content The message content or builder.
   * @param {MessageOptions} [options] The message options, only when not using the message builder.
   * @returns {Message[]}
   */
  new(content: MessageAdd, options?: MessageOptions): Promise<Message[]>;

  /**
   * Resolves user message parameters into api messages.
   * @param {MessageAdd} content The message content or builder
   * @param {MessageOptions} options The message options.
   */
  resolveMessageData(content: MessageAdd, options?: MessageOptions): Promise<RequestData[]>;

  /**
   * Delete from 2-100 messages in a single request.
   * @param {MessageResolvable[]} messages The messages to delete.
   * @param {BulkDeleteOptions} [options] The bulk-delete options.
   * @returns {Promise<string[]>} IDs of the deleted messages.
   */
  bulkDelete(messages: MessageResolvable[] | number, options?: BulkDeleteOptions): Promise<string[]>;

  /**
   * Fetches a single message from the channel.
   * @param {string} id ID of the message to fetch.
   * @param {boolean} [force] Whether to skip checking if the message is already cached.
   * @returns {Promise<Message>} The fetched (or cached) message.
   */
  fetch(id: string, force?: boolean): Promise<Message>;
  /**
   * Fetches 2-100 messages from the channel.
   * @param {MessageFetchOptions} options The fetch options.
   * @returns {Promise<Collection<string, Message>>} The fetched messages.
   */
  fetch(options: MessageFetchOptions): Promise<Collection<string, Message>>;
}

export type Builder = (builder: MessageBuilder) => MessageBuilder | Promise<MessageBuilder>;
export type MessageResolvable = BaseResolvable<Message>;
export type MessageAdd = string | Embed | Builder | MessageBuilder | MessageOptions;

export interface BulkDeleteOptions {
  filterOld?: boolean;
  reason?: string;
}

export interface MessageFetchOptions {
  around?: string;
  before?: string;
  after?: string;
  limit?: number;
}

export interface MessageDeleteOptions {
  /**
   * How long to wait before deleting the message.
   */
  wait?: string | number;
  /**
   * The reason for deleting the message.
   */
  reason?: string;
}

/**
 * Modified version of @klasa/core's message builder.
 */
export class MessageBuilder {
  /**
   * The message data.
   * @type {MessageData}
   */
  body: PartialExcept<MessageData, "allowed_mentions">;
  /**
   * The files to attach.
   * @type {File[]}
   */
  files: File[];

  /**
   * Creates a new instanceof MessageBuilder.
   * @param {MessageOptions | MessageEditOptions} data The data to pre-define.
   */
  constructor(data?: MessageOptions | MessageEditOptions);

  /**
   * Set the content of this message.
   * @param {string} [content]
   */
  content(content?: string | null): MessageBuilder;

  /**
   * Sets the embed of this message.
   * @param {APIEmbed | null | Embed} [embed] The embed to set
   */
  embed(embed?: APIEmbed | null | Embed): MessageBuilder;

  /**
   * Sets the nonce of this message
   * @param {string | number} [nonce] The nonce to set
   * @returns {MessageBuilder}
   */
  nonce(nonce?: number | string): MessageBuilder;

  /**
   * Adds a message attachment to this message
   * @param {File | File[]} file The attachment
   * @returns {MessageBuilder}
   */
  attach(file: File | File[]): MessageBuilder;

  /**
   * Change whether this message will have text-to-speech.
   * @param {boolean} [tts] The tts of this message
   * @returns {MessageBuilder}
   */
  tts(tts?: boolean): MessageBuilder;

  /**
   * Makes @everyone and @here actually ping people.
   * @returns {MessageBuilder}
   */
  parseEveryone(): MessageBuilder;

  /**
   * Allow specific users to be mentioned.
   * @param {...string} users user The {@link User user}s you want to mention.
   * @returns {MessageBuilder}
   */
  parseUsers(...users: string[]): MessageBuilder;

  /**
   * Allow specific roles to be pinged.
   * @param {...string} roles The {@link Role role}s you want to mention.
   * @returns {MessageBuilder}
   */
  parseRoles(...roles: string[]): MessageBuilder;

  /**
   * Splits the message into chunks
   * @param {SplitOptions} [options]
   * @returns {RequestData[]}
   */
  split(options?: SplitOptions): RequestData[];

  /**
   * Internal shared method to split the content by.
   * @param {SplitOptions} [options]
   */
  protected _split({ maxLength, char, prepend, append }?: SplitOptions): string[];
}

export type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Required<Pick<T, K>>;
export type RequiredExcept<T, K extends keyof T> = Partial<Pick<T, K>> & Required<Omit<T, K>>;

export interface MessageData {
  content?: string | null;
  embed?: APIEmbed | null;
  nonce?: number | string;
  tts?: boolean;
  allowed_mentions?: Required<AllowedMentions>;
}

export interface MessageEditOptions {
  content?: string | null;
  embed?: APIEmbed | null;
  flags?: MessageFlags;
}

export interface AllowedMentions {
  parse?: ("users" | "roles" | "everyone")[];
  roles?: string[];
  users?: string[];
}

export interface MessageOptions extends Omit<MessageData, "allowed_mentions"> {
  files?: File[];
  allowedMentions?: Required<AllowedMentions>;
}

export interface SplitOptions {
  maxLength?: number;
  char?: string;
  prepend?: string;
  append?: string;
}

export class MemberRoleManager extends ProxyManager<Role> {
  /**
   * The member this role manager belongs to.
   * @type {Member}
   */
  readonly member: Member;

  /**
   * Creates a new instanceof MemberRoleManager.
   * @param {Member} member The member this manager belongs to.
   * @param {Array<string>} [roles] The roles.
   */
  constructor(member: Member, roles?: string[]);

  /**
   * The highest role that this member has.
   * @type {Role | null}
   */
  get highest(): Role | null;

  /**
   * The guild the channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Adds a role to the member.
   * @param {RoleResolvable} role
   * @param {string} [reason]
   */
  add(role: RoleResolvable, reason?: string): Promise<this>;

  /**
   * Removes a role from the member.
   * @param {RoleResolvable} role
   * @param {string} [reason]
   */
  remove(role: RoleResolvable, reason?: string): Promise<this>;
}

export class PinnedMessageManager extends ProxyManager<Message> {
  /**
   * The channel that this manager belongs to.
   * @type {TextBasedChannel}
   */
  readonly channel: TextBasedChannel;

  /**
   * @param {TextBasedChannel} channel
   * @param {snowflake[]} [pinned]
   */
  constructor(channel: TextBasedChannel, pinned?: snowflake[]);

  /**
   * Unpins a message to the channel.
   * @param {MessageResolvable} message The message to unpin.
   * @param {string} [reason] Reason for unpinning the message.
   * @returns {Promise<Message>} The unpinned message.
   */
  remove(message: MessageResolvable, reason?: string): Promise<Message | null>;

  /**
   * Pins a message to the channel.
   * @param {MessageResolvable} message The message to pin.
   * @param {string} [reason] Reason for pinning the message.
   * @returns {Promise<Message>} The pinned message.
   */
  add(message: MessageResolvable, reason?: string): Promise<Message | null>;
}

export class ChannelInviteManager extends ProxyManager<Invite> {
  /**
   * @param {Channel} channel The channel.
   * @param {string[]} [invites] Invites.
   */
  constructor(channel: GuildChannel, invites?: string[]);

  /**
   * The channel that this manager belongs to.
   * @type {Channel}
   */
  get channel(): GuildChannel;

  /**
   * Creates a new invite for this channel.
   * @param {AddChannelInvite} data
   * @returns {Promise<Invite>}
   */
  add(data?: AddChannelInvite): Promise<Invite>;

  /**
   * Removes an invite.
   * @param {InviteResolvable} invite The invite to remoted.
   */
  remove(invite: InviteResolvable): Promise<Readonly<Invite> | null>;

  /**
   * Fetches all invites for the channel.
   * @returns {Promise<ChannelInviteManager>}
   */
  fetch(): Promise<ChannelInviteManager>;
}

export enum TargetUserType {
  Stream = 1
}

export interface AddChannelInvite {
  /**
   * Duration of invite in seconds before expiry, or 0 for never.
   * @type {number}
   * @default 86400 (24 hours)
   */
  maxAge?: number;
  /**
   * Max number of uses or 0 for unlimited.
   * @type {?number}
   * @default 0
   */
  maxUses?: number;
  /**
   * Whether this invite only grants temporary membership
   * @type {?boolean}
   * @default false
   */
  temporary?: boolean;
  /**
   * If true, don't try to reuse a similar invite (useful for creating many unique one time use invites).
   * @type {?boolean}
   * @default false
   */
  unique?: boolean;
  /**
   * The target user for this invite.
   * @type {UserResolvable}
   */
  targetUser?: UserResolvable;
  /**
   * The type of target user for this invite.
   * @type {TargetUserType}
   */
  targetUserType?: TargetUserType;
}

export class BanManager extends BaseManager<Ban> {
  /**
   * The guild this ban manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof BanManager.
   * @param {Guild} guild The {@link Guild guild} instance.
   */
  constructor(guild: Guild);

  /**
   * Create a guild ban, and optionally delete previous messages sent by the banned user.
   * @param {UserResolvable} user The user to ban.
   * @param {BanOptions} [options] The ban options. {@see BanOptions}
   * @returns {Promise<BanManager>} The {@link BanManager ban manager}
   */
  add(user: UserResolvable, options?: BanOptions): Promise<BanManager>;

  /**
   * Remove the ban for a user.
   * @param {UserResolvable} user The {@link User user} to unban.
   * @param {string} [reason] The audit-log ban reason.
   * @returns {Promise<Ban | null>} The removed {@link Ban ban}.
   */
  remove(user: UserResolvable, reason?: string): Promise<Ban | null>;

  /**
   * Fetches a ban from the guild.
   * @param {FetchBans} options The fetch options.
   * @param {boolean} force Whether to skip checking if the ban is already cached.
   * @returns {Promise<Ban>} The fetched (or cached) {@link Ban ban}.
   */
  fetch(options: {
    id: string;
    cache?: boolean;
  }, force?: boolean): Promise<Ban>;
  /**
   * Fetches all bans for the guild and populates a new {@link Collection collection}.
   * @param {FetchBans} options The fetch options.
   * @returns {Promise<Collection<string, Ban>>} The new {@link Collection collection}.
   */
  fetch(options: {
    cache: false;
  }): Promise<Collection<string, Ban>>;
  /**
   * Fetches all bans for the guild and populates this manager.
   * @param {FetchBans} options The fetch options.
   * @returns {Promise<BanManager>} The ban manager.
   */
  fetch(options: {
    cache?: true;
  }): Promise<BanManager>;
}

export interface BanOptions {
  /**
   * Reason for the ban
   */
  reason?: string;
  /**
   * Number of days to delete messages for (0-7)
   */
  days?: number;
}

export interface FetchBans {
  id?: string;
  cache?: boolean;
}

export const CLASS: unique symbol;
export const STRUCTURE: unique symbol;

export class BaseManager<S extends Base> {
  /**
   * The class to use.
   * @type {Class}
   * @protected
   */
  protected [CLASS]: Class<S>;
  /**
   * The structure this manager manages.
   * @type {DiscordStructure}
   * @protected
   */
  protected [STRUCTURE]: DiscordStructure;


  /**
   * @param {Client} client The client instance.
   * @param {ManagerData} data The data for this manager.
   */
  constructor(client: Client, data: ManagerData<S>);

  /**
   * The number of cached items in this.
   * @type {number}
   */
  get size(): number;

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * The custom inspect text.
   * @returns {string}
   */
  get [Util.inspect.custom](): string;

  /**
   * The cache of this base manager.
   * @type {Cache<Base>}
   */
  get cache(): Cache<S>;

  static [Symbol.species](): typeof Collection;

  /**
   * Resolves something into a usable object.
   * @param {BaseResolvable} item The item to resolve.
   * @returns {Promise<Base | null>}
   */
  resolve(item: BaseResolvable<S>): S | null;

  /**
   * Resolves something into an ID
   * @param {string | Base} data The data to resolve.
   * @returns {string} The resolved ID or null if nothing was found.
   */
  resolveId(data: BaseResolvable<S>): string | null;

  /**
   * Clears the cache.
   * @type {string}
   */
  clear(): BaseManager<S>;

  /**
   * Gets an item from the cache.
   * @param {string} id
   * @returns {Base | null}
   */
  get(id: string): S | undefined;

  /**
   * Whether an item is in the cache.
   * @param {string} id The ID of the item to check for.
   * @returns {boolean}
   */
  has(id: string): boolean;

  /**
   * The value iterator for this manager.
   * @returns {IterableIterator<string, Base>}
   */
  [Symbol.iterator](): IterableIterator<[ string, S ]>;

  /**
   * Runs a function on each entry of this manager
   * @param {Function} fn The function ran each iteration.
   * @param {any} thisArg Optional binding for the predicate.
   * @returns {Collection<string, Base>}
   */
  forEach(fn: (value: S, key: string, col: Map<string, S>) => void, thisArg?: unknown): void;

  /**
   * The json representation of this manager.
   * @returns {Array<string>}
   */
  toJSON(): string[];

  /**
   * The keys iterator.
   * @returns {IterableIterator}
   */
  keys(): IterableIterator<string>;

  /**
   * The keys iterator.
   * @returns {IterableIterator}
   */
  entries(): IterableIterator<[ string, S ]>;

  /**
   * The keys iterator.
   * @returns {IterableIterator}
   */
  values(): IterableIterator<S>;

  /**
   * Adds an item to this manager.
   * @param {Base} item The item to add.
   * @protected
   */
  protected _set(item: S): S;

  /**
   * Adds an item to this manager.
   * @param {Dictionary} data
   * @param {...*} args Args to pass to the class.
   * @protected
   */
  protected _add(data: Dictionary, ...args: unknown[]): S;
}

export type BaseResolvable<T extends Base> = T | string | {
  id: string;
};

export interface BaseManager<S extends Base> {
  /**
   * The first item in this manager.
   * @type {Base | null}
   */
  first: S | null;
  /**
   * The last item in this manager.
   * @type {Base | null}
   */
  last: S | null;

  /**
   * Tests whether or not an entry in this manager meets the provided predicate.
   * @param {Function} predicate A predicate that tests all entries.
   * @param {any} thisArg An optional binding for the predicate function.
   */
  some(predicate: (value: S, key: string, col: this) => unknown, thisArg?: unknown): boolean;

  /**
   * Collection#forEach but it returns the manager instead of nothing.
   * @param {Function} fn The function to be ran on all entries.
   * @param {any} thisArg An optional binding for the fn parameter.
   */
  each(fn: (value: S, key: string, col: this) => unknown, thisArg?: unknown): this;

  /**
   * Returns a filtered manager based on the provided predicate.
   * @param fn The predicate used to determine whether or not an entry can be passed to the new collection.
   * @param {any} thisArg Optional binding for the predicate.
   * @returns {Collection<string, Base>}
   */
  filter(fn: (value: S, key: string, col: this) => boolean, thisArg?: unknown): Collection<string, S>;

  /**
   * Finds a value using a predicate from this manager.
   * @param {Function} fn Function used to find the value.
   * @param {any} thisArg Optional binding to use.
   */
  find(fn: (value: S, key: string, col: this) => boolean, thisArg?: unknown): S | null;

  /**
   * Reduces this manager down into a single value.
   * @template {any} A
   * @param {Function} fn The function used to reduce this manager.
   * @param {A} acc The accumulator.
   * @param {any} thisArg Optional binding for the reducer function.
   * @returns
   */
  reduce<A>(fn: (acc: A, value: S, key: string, col: this) => A, acc: A, thisArg?: unknown): A;

  /**
   * Maps this manager into an array. Array#map equivalent.
   * T - The type of element of each element in the returned array.
   * @template {any} T
   * @param {Function} fn Function used to map values to an array.
   * @param {any} thisArg Optional binding for the map function.
   * @returns {T[]}
   */
  map<T>(fn: (value: S, key: string, col: this) => T, thisArg?: unknown): T[];

  /**
   * Returns a clone of this collection.
   * @returns {Collection<string, Base>}
   */
  clone(): Collection<string, S>;
}

export interface ManagerData<S extends Base> {
  /**
   * The class to use when instantiating things.
   * @type {Class}
   */
  class: Class<S>;
  /**
   * The structure that this manager handles.
   * @type {DiscordStructure}
   */
  structure: DiscordStructure;
}

export class ChannelManager extends BaseManager<Channel> {
  /**
   * Creates a new instanceof ChannelManager
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Get a channel.
   * @param {string} id ID of the channel to get.
   * @returns {Channel} The channel
   */
  get<T extends Channel = Channel>(id: string): T | undefined;

  /**
   * Adds a new channel to this manager.
   * @private
   */
  protected _add(data: APIChannel, guild?: Guild): Channel;
}

export class DMChannelManager extends BaseManager<DMChannel> {
  /**
   * Creates a new instanceof DMChannelManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Closes a DM channel.
   * @param {DMResolvable} channel The DM to close.
   * @returns {DMChannel} The closed DM channel.
   */
  close(channel: DMResolvable): Promise<DMChannel>;

  /**
   * Creates a new DM between the current user and someone else.
   * @param {BaseResolvable} user The user.
   * @returns {DMChannel} The new dm channel.
   */
  new(user: UserResolvable): Promise<DMChannel>;

  /**
   * Adds a new DM channel to this manager.
   * @param {APIChannel} data
   * @protected
   */
  protected _add(data: APIChannel): DMChannel;
}

export type DMResolvable = BaseResolvable<DMChannel>;

export class GuildChannelManager extends BaseManager<GuildChannel> {


  /**
   * Creates a new instanceof GuildChannelCache
   * @param {Guild} guild The {@link Guild guild} instance.
   */
  constructor(guild: Guild);

  /**
   * The guild this channel cache belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Get a guild channel.
   * @param {string} id ID of the channel to get.
   * @returns {GuildChannel} The guild channel
   */
  get<T extends GuildChannel = GuildChannel>(id: string): T | undefined;

  /**
   * Removes a channel from the guild.
   * @param {GuildChannel} channel The channel to remove.
   * @param {string} [reason] The reason that the channel was deleted.
   * @returns {GuildChannel | null} The removed channel.
   */
  remove<T extends GuildChannel = GuildChannel>(channel: BaseResolvable<T>, reason?: string): Promise<T | null>;

  /**
   * Fetches a {@link GuildChannel guild channel} from the discord api.
   * @param {string} channelId ID of the channel to fetch.
   * @param {boolean} [force] Skips checking if the channel is already cached.
   * @returns {Promise<GuildChannel>} The fetched channel.
   */
  fetch<T extends GuildChannel = GuildChannel>(channelId: string, force?: boolean): Promise<T>;
  /**
   * Fetches all channels in the guild.
   * @returns {Promise<Collection<string, GuildChannel>>} The {@link GuildChannel guild channel} cache.
   */
  fetch(): Promise<Collection<string, GuildChannel>>;

  /**
   * Adds a new item to this manager.
   * @data {APIChannel} data
   * @private
   */
  protected _add(data: APIChannel): GuildChannel;
}

export class GuildManager extends BaseManager<Guild> {
  /**
   * Creates a new instanceof GuildManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Deletes the guild. Current user must be the owner.
   * @param {GuildResolvable} guild The guild to remove.
   * @returns {Guild | null} The guild that was removed.
   */
  remove(guild: GuildResolvable): Promise<Guild | null>;

  /**
   * Leaves a guild.
   * @param {GuildResolvable} guild The guild to leave.
   * @returns {?Guild} The guild that the current user left.
   */
  leave(guild: GuildResolvable): Promise<Guild | null>;

  /**
   * Fetches a guild from the discord api.
   * @param {string} guild The ID of the guild to fetch.
   * @returns {Promise<Guild>} The fetched guild.
   */
  fetch(guild: string): Promise<Guild>;
}

export type GuildResolvable = BaseResolvable<Guild>;

export class MemberManager extends BaseManager<Member> {
  /**
   * The guild this member manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof MemberManager.
   * @param {Guild} guild The guild instance.
   */
  constructor(guild: Guild);

  /**
   * Resolves something into a guild member {@link Member member}.
   * @param {MemberResolvable} item The data to resolve.
   * @returns {Member | null} The resolved ID or null if nothing was found.
   */
  resolve(item: BaseResolvable<Member>): Member | null;

  /**
   * Resolves something into an ID.
   * @param {MemberResolvable} data The data to resolve.
   * @returns {string | null} The resolved ID or null if nothing was found.
   */
  resolveId(data: MemberResolvable): string | null;

  /**
   * Kicks a member or user from the {@link Guild guild}.
   * @param {MemberResolvable} target The {@link Member member} or {@link User user} to kick.
   * @param {string} [reason] The reason for the audit log entry.
   * @returns {Member | null} The kicked {@link Member member}.
   */
  kick(target: MemberResolvable, reason?: string): Promise<Readonly<Member> | null>;

  /**
   * Bans a member or user from the {@link Guild guild}.
   * @param {MemberResolvable} target The {@link Member member} or {@link User user} to ban.
   * @param {BanOptions} [options] The ban options.
   * @returns {Member | null} The banned {@link Member member}.
   */
  ban(target: MemberResolvable, options?: BanOptions): Promise<MemberResolvable | null>;

  /**
   * Fetch a member from the discord api.
   * @param {string} id User ID of the member to fetch.
   * @param {boolean} [force] Whether to skip checking if the member is already cached.
   * @returns {Member} The fetched (or cached) member.
   */
  fetch(id: string, force?: boolean): Promise<Member>;
  /**
   * Fetch 1-1000 members from the guild.
   * @param {FetchMembers} options Options to use when fetching.
   * @returns {Collection<string, Member>} The fetched members.
   */
  fetch(options?: FetchMembers): Promise<Collection<string, Member>>;

  /**
   * Get the number of members that would be removed in a 'non-dry' prune.
   * @param {DryPruneOptions} options The options for the 'dry' prune.
   * @param {string} [reason] The audit-log reason.
   * @returns {number} The number of members that would be removed in a 'non-dry' prune.
   */
  prune(options: DryPruneOptions, reason?: string): Promise<number>;
  /**
   * Starts a member prune operation.
   * @param {PruneOptions} options Options for the prune operation.
   * @param {string} [reason] The audit-log reason.
   * @returns {number | null} The number or removed members, only null if the 'computePruneCount' option was omitted or set to false.
   */
  prune(options: PruneOptions, reason?: string): Promise<number | null>;
}

export type MemberResolvable = BaseResolvable<User | Member>;

export interface FetchMembers {
  /**
   * Max number of members to fetch (1-1000)
   */
  limit?: number;
  /**
   * The highest user id in the previous page
   */
  after?: string;
}

export interface DryPruneOptions {
  /**
   * If set to true:
   * Returns the number ('pruned' property) of members that would be removed in a "non-dry" prune operation.
   */
  dry: true;
  /**
   * Number of days to count prune for (1 or more)
   */
  days?: number;
  /**
   * Role(s) to include
   */
  includeRoles?: string | string[];
}

export interface PruneOptions extends Omit<DryPruneOptions, "dry"> {
  /**
   * Whether 'pruned' is returned, discouraged for large guilds.
   */
  computePruneCount?: boolean;
  /**
   * Requests a prune operation.
   */
  dry?: false;
}

export class OverwriteManager extends BaseManager<PermissionOverwrite> {


  /**
   * Creates a new instanceof OverwriteManager.
   * @param {GuildChannel} channel The guild channel this manager belongs to.
   */
  constructor(channel: GuildChannel);

  /**
   * The channel that this manager belongs to.
   * @type {GuildChannel}
   */
  get channel(): GuildChannel;

  /**
   * The guild the channel belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Adds a new permission overwrite to this channel.
   * @param {Member} target The overwrite target, either a guild role or member.
   * @param {OverwriteOptions} options Options for the overwrite.
   */
  add(target: Member | Role | string, options: OverwriteOptions): Promise<PermissionOverwrite>;

  /**
   * Get the overwrites for a guild member.
   * @param {Member} member The member
   */
  for(member: Member): MemberOverwrites;
  /**
   * Get the overwrites for a role.
   * @param {Role} role The role.
   * @returns {RoleOverwrites}
   */
  for(role: Role): RoleOverwrites;
}

export interface OverwriteOptions {
  type?: "role" | "member";
  allow: PermissionResolvable;
  deny: PermissionResolvable;
  reason?: string;
}

export interface MemberOverwrites {
  everyone?: PermissionOverwrite;
  member?: PermissionOverwrite;
  roles: PermissionOverwrite[];
}

export interface RoleOverwrites {
  everyone?: PermissionOverwrite;
  role?: PermissionOverwrite;
}

export class PresenceManager extends BaseManager<Presence> {
  /**
   * The guild this manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof PresenceManager.
   * @param {Guild} guild The guild this manager belongs to.
   */
  constructor(guild: Guild);
}

export class GuildIntegrationManager extends BaseManager<Integration> {


  /**
   * @param {Guild} guild The guild that this manager belongs to.
   */
  constructor(guild: Guild);

  /**
   * The guild that this manager belongs to.
   * @type {Guild}
   */
  get guild(): Guild;

  /**
   * Add a new guild integration.
   * @param {string} id ID of the integration
   * @param {string} type The type of integration
   */
  add(id: string, type: string): Promise<Integration>;

  /**
   * Removes an integration from the guild.
   * @param {IntegrationResolvable} integration The integration to remove.
   * @param {string} [reason] Reason for deleting the integration.
   * @returns {Promise<this>}
   */
  remove(integration: IntegrationResolvable, reason?: string): Promise<IntegrationResolvable>;

  /**
   * Fetches all integrations for this guild.
   * @returns {Promise<GuildIntegrationManager>}
   */
  fetch(): Promise<this>;
}

export type IntegrationResolvable = BaseResolvable<Integration>;

export interface AddIntegration {
  /**
   * The integration id.
   * @type {snowflake}
   */
  id: snowflake;
  /**
   * The integration type.
   * @type {string}
   */
  type: string;
}

export class ProxyManager<S extends Base> {
  /**
   * The manager this proxies.
   * @type {BaseManager}
   */
  readonly manager: BaseManager<S>;


  /**
   * Creates a new proxy manager.
   * @param {BaseManager} manager
   * @param {string[]} [keys]
   */
  constructor(manager: BaseManager<S>, keys?: string[]);

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * Cached items for this manager.
   * @type {Collection<string, S>}
   */
  get cache(): Collection<string, S>;

  /**
   * Returns the number of keys in this collection.
   * @type {number}
   */
  get size(): number;

  /**
   * Returns the string tag of this instance.
   * @type {string}
   */
  get [Symbol.toStringTag](): string;

  /**
   * Get am item from this shared collection.
   * @param {any} key
   * @returns {* | undefined}
   */
  get(key: string): S | undefined;

  /**
   * Whether this shared collections contains a key.
   * @param {any} key
   * @returns {boolean}
   */
  has(key: string): boolean;

  /**
   * Clears all keys from this store.
   * @returns {ProxyManager}
   */
  clear(): this;

  /**
   * Executes a provided function for each k/v pair in the store.
   * @param {Function} callbackFn
   * @param {any} [thisArg]
   */
  forEach(callbackFn: (value: S, key: string, map: Map<string, S>) => void, thisArg?: unknown): void;

  /**
   * Returns a new iterator that contains the k/v pairs for each element in this store.
   * @returns {IterableIterator}
   */
  [Symbol.iterator](): IterableIterator<[ string, S ]>;

  /**
   * Returns a new iterator that contains the k/v pairs for each element in this store.
   * @returns {IterableIterator}
   */
  entries(): IterableIterator<[ string, S ]>;

  /**
   * Returns a new iterator that contains the keys for each element in this store.
   * @returns {IterableIterator<*>}
   */
  keys(): IterableIterator<string>;

  /**
   * Returns a new iterator that contains all the values for each element in this store.
   * @returns {IterableIterator<*>}
   */
  values(): IterableIterator<S>;

  /**
   * Removes a key from this store.
   * @param {any} key
   * @returns {boolean}
   */
  protected _delete(key: string): boolean;

  /**
   * Adds a key to the
   * @param {any} key
   * @returns {ProxyManager}
   */
  protected _set(key: string): this;
}

export interface ProxyManager<S extends Base> {
  /**
   * The first item in this manager.
   * @type {Base | null}
   */
  first: S | null;
  /**
   * The last item in this manager.
   * @type {Base | null}
   */
  last: S | null;

  /**
   * Tests whether or not an entry in this manager meets the provided predicate.
   * @param {Function} predicate A predicate that tests all entries.
   * @param {any} thisArg An optional binding for the predicate function.
   */
  some(predicate: (value: S, key: string, col: this) => unknown, thisArg?: unknown): boolean;

  /**
   * Collection#forEach but it returns the manager instead of nothing.
   * @param {Function} fn The function to be ran on all entries.
   * @param {any} thisArg An optional binding for the fn parameter.
   */
  each(fn: (value: S, key: string, col: this) => unknown, thisArg?: unknown): this;

  /**
   * Finds a value using a predicate from this manager.
   * @param {Function} fn Function used to find the value.
   * @param {any} thisArg Optional binding to use.
   */
  find(fn: (value: S, key: string, col: this) => boolean, thisArg?: unknown): S | null;

  /**
   * Reduces this manager down into a single value.
   * @template {any} A
   * @param {Function} fn The function used to reduce this manager.
   * @param {A} acc The accumulator.
   * @param {any} thisArg Optional binding for the reducer function.
   * @returns
   */
  reduce<A>(fn: (acc: A, value: S, key: string, col: this) => A, acc: A, thisArg?: unknown): A;

  /**
   * Maps this manager into an array. Array#map equivalent.
   * T - The type of element of each element in the returned array.
   * @template {any} T
   * @param {Function} fn Function used to map values to an array.
   * @param {any} thisArg Optional binding for the map function.
   * @returns {T[]}
   */
  map<T>(fn: (value: S, key: string, col: this) => T, thisArg?: unknown): T[];

  /**
   * Returns a clone of this collection.
   * @returns {Collection<string, Base>}
   */
  clone(): Collection<string, S>;
}

export class RoleManager extends BaseManager<Role> {
  /**
   * The guild this role manager belongs to.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof RoleManager.
   * @param {Guild} guild The guild this role manager belongs to.
   */
  constructor(guild: Guild);

  /**
   * The highest role based on position in this store.
   * @type {Role | null}
   */
  get highest(): Role | null;

  /**
   * Add a role to this store.
   * @param {RoleAddOptions} data The role data.
   * @param {string} [reason] The reason for adding this role..
   */
  add(data: RoleAddOptions, reason?: string): Promise<Role>;

  /**
   * Removes a role from the role list.
   * @param {BaseResolvable} role The role to remove.
   * @param {string} [reason] The reason for removing the role.
   */
  remove(role: RoleResolvable, reason?: string): Promise<Role | null>;

  /**
   * Fetches a role from the discord api.
   * @param {string} role The ID of the role to fetch.
   * @param {boolean} [force] Skip checking if the role is already cached.
   * @returns {Promise<Role>} The fetched role.
   */
  fetch(role: string, force?: boolean): Promise<Role>;
  /**
   * Fetches all roles for the guild.
   * @returns {Promise<Collection<string, Role>>}
   */
  fetch(): Promise<Collection<string, Role>>;
}

export type RoleResolvable = BaseResolvable<Role>;

export interface RoleAddOptions {
  name?: string;
  permissions?: PermissionResolvable | number;
  color?: string | number;
  hoisted?: boolean;
  mentionable?: boolean;
}

export class InviteManager extends BaseManager<Invite> {
  /**
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Deletes an invite.
   * @param {InviteResolvable} invite The invite to delete.
   * @returns {Promise<Readonly<Invite> | null>} The invite to delete.
   */
  remove(invite: InviteResolvable): Promise<Readonly<Invite> | null>;

  /**
   * Fetches an invite from the API.
   * @param {string} code The invite code.
   * @param {boolean} [withCounts] Whether the invite should include counts.
   * @returns {Promise<Invite>}
   */
  fetch(code: string, withCounts?: boolean): Promise<Invite>;

  /**
   * Adds a new invite to the cache.
   * @param {APIExtendedInvite} data The data packet to add
   */
  protected _add(data: APIInvite | APIExtendedInvite): Invite;
}

export type InviteResolvable = BaseResolvable<Invite>;

export class UserManager extends BaseManager<User> {
  /**
   * Creates a new instanceof UserManager.
   * @param {Client} client The client instance.
   */
  constructor(client: Client);

  /**
   * Fetches a user from the discord api.
   * @param {string} userId The ID of the user to fetch.
   * @returns {Promise<User>} The fetched user.
   */
  fetch(userId: string): Promise<User>;
}

export type UserResolvable = BaseResolvable<User>;

export class VoiceStateManager extends BaseManager<VoiceState> {
  /**
   * The guild instance.
   * @type {Guild}
   */
  readonly guild: Guild;

  /**
   * Creates a new instanceof VoiceStateManager.
   * @param {Guild} guild The guild instance.
   */
  constructor(guild: Guild);
}

export abstract class Base {
  /**
   * The ID of this instance.
   * @type {string}
   */
  abstract readonly id: string;

  /**
   * Creates a new instance of Base.
   * @param {Client} client The client instance.
   */
  protected constructor(client: Client);

  /**
   * The client instance.
   * @type {Client}
   */
  get client(): Client;

  /**
   * Clones this instance.
   * @returns {Base}
   */
  _clone(): this;

  /**
   * Freezes this structure.
   * @returns {Readonly<this>}
   */
  _freeze(): Readonly<this>;

  /**
   * Get the JSON representation of this instance.
   * @returns {Dictionary}
   */
  toJSON(): Dictionary;

  /**
   * @param {...*} [data]
   * @protected
   */
  protected _patch(...data: unknown[]): this;
}

export const neo: Extender<Record<string, import("@neocord/utils").Class<any>>>;
export type Structures = {
  WelcomeChannel: typeof WelcomeChannel;
  WelcomeScreen: typeof WelcomeScreen;
  Ban: typeof Ban;
  Guild: typeof Guild;
  Invite: typeof Invite;
  Member: typeof Member;
  PermissionOverwrite: typeof PermissionOverwrite;
  Presence: typeof Presence;
  Role: typeof Role;
  VoiceState: typeof VoiceState;
  Message: typeof Message;
  User: typeof User;
  MessageAttachment: typeof MessageAttachment;
  Integration: typeof Integration;
  CategoryChannel: typeof CategoryChannel;
  GuildChannel: typeof GuildChannel;
  NewsChannel: typeof NewsChannel;
  StoreChannel: typeof StoreChannel;
  VoiceChannel: typeof VoiceChannel;
  TextChannel: typeof TextChannel;
  DMChannel: typeof DMChannel;
  Channel: typeof Channel;
};

export abstract class SnowflakeBase extends Base {
  /**
   * The date when this object was created.
   * @type {Date}
   */
  get createdAt(): Date;

  /**
   * The time when this object was created.
   * @type {number}
   */
  get createdTimestamp(): number;

  /**
   * The snowflake data.
   * @type {Snowflake}
   */
  get snowflake(): DeconstructedSnowflake;
}

export enum Permission {
  CreateInstantInvite = 1,
  KickMembers = 2,
  BanMembers = 4,
  Administrator = 8,
  ManageChannels = 16,
  ManageGuild = 32,
  AddReactions = 64,
  ViewAuditLog = 128,
  PrioritySpeaker = 256,
  Stream = 512,
  ViewChannel = 1024,
  SendMessages = 2048,
  SendTTSMessage = 4096,
  ManageMessages = 8192,
  EmbedLinks = 16384,
  AttachFiles = 32768,
  ReadMessageHistory = 65536,
  MentionEveryone = 131072,
  UseExternalEmojis = 262144,
  ViewGuildInsights = 524288,
  Connect = 1048576,
  Speak = 2097152,
  MuteMembers = 4194304,
  DeafenMembers = 8388608,
  MoveMembers = 16777216,
  UseVAD = 33554432,
  ChangeNickname = 67108864,
  ManageNicknames = 134217728,
  ManageRoles = 268435456,
  ManageWebhooks = 536870912,
  ManageEmojis = 1073741824
}

export class Permissions extends BitField<PermissionResolvable> {
  /**
   * All Permission Flags.
   * @type {Permission}
   */
  static FLAGS: typeof Permission;
  /**
   * The default permissions for a role.
   * @type {number}
   */
  static DEFAULT: number;
  /**
   * Permissions that can't be influenced by channel overwrites, even if explicitly set.
   * @type {number}
   */
  static GUILD_SCOPE_PERMISSIONS: number;

  /**
   * Makes a permission name more readable.
   * @param {Permission} permission The permission
   */
  static humanize(permission: Permission): string;

  /**
   * Checks whether the bitfield has a permission, or any of multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override
   */
  any(permission: PermissionResolvable, checkAdmin?: boolean): boolean;

  /**
   * Checks whether the bitfield has a permission, or multiple permissions.
   * @param {PermissionResolvable} permission Permission(s) to check for
   * @param {boolean} [checkAdmin] Whether to allow the administrator permission to override
   */
  has(permission: PermissionResolvable, checkAdmin?: boolean): boolean;
}

export type PermissionResolvable =
  keyof typeof Permission
  | Permission
  | number
  | BitFieldObject
  | (keyof typeof Permission | number | BitFieldObject)[];

export abstract class ImageResolver {
  /**
   * Whether a buffer is of the jpeg format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isJpg(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the png format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isPng(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the webp format.
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isWebp(buffer: Buffer): boolean;

  /**
   * Whether a buffer is of the gif format
   * @param {Buffer} buffer
   * @returns {boolean}
   */
  static isGif(buffer: Buffer): boolean;

  /**
   * Get the image format of a buffer.
   * @param {Buffer} buffer
   * @returns {ImageFormats | null}
   */
  static getImageFormat(buffer: Buffer): ImageFormats | null;

  /**
   * Resolves a buffer into a base64 string.
   * @param {Buffer | string} data
   * @returns {string}
   */
  static resolveBase64(data: Buffer | string): string;

  /**
   * Resolves a file.
   * @param {ImageResolvable} resource
   * @returns {Promise<Buffer>}
   */
  static resolveFile(resource: ImageResolvable): Promise<Buffer>;

  /**
   * Resolve an image into a base64
   * @param {ImageResolvable} data
   * @returns {Promise<string>}
   */
  static resolveImage(data: ImageResolvable): Promise<string>;
}

export type ImageResolvable = Buffer | Readable | string;

export enum ImageFormats {
  WEBP = "image/webp",
  GIF = "image/gif",
  PNG = "image/png",
  JPEG = "image/jpeg"
}

export enum ClientEvent {
  GuildAvailable = "guildAvailable",
  GuildUnavailable = "guildUnavailable",
  RoleCreate = "roleCreate",
  RoleDelete = "roleDelete",
  RoleUpdate = "roleUpdate"
}

export enum DebugTopic {
  PacketHandling = "packet handling",
  Janitor = "janitor"
}

export enum DiscordStructure {
  Guild = 0,
  Role = 1,
  Channel = 2,
  Emoji = 3,
  Presence = 4,
  Message = 5,
  Overwrite = 6,
  VoiceState = 7,
  DMChannel = 8,
  Ban = 9,
  Member = 10,
  User = 11,
  Invite = 12,
  GuildChannel = 13,
  Integration = 14
}

export enum Color {
  Default = 0,
  White = 16777215,
  Aqua = 1752220,
  Green = 3066993,
  Blue = 3447003,
  Yellow = 16776960,
  Purple = 743868,
  LuminousVividPink = 15277667,
  Gold = 15844367,
  Orange = 15105570,
  Red = 15158332,
  Grey = 9807270,
  Navy = 3426654,
  DarkAqua = 1146986,
  DarkGreen = 2067276,
  DarkBlue = 2123412,
  DarkPurple = 7419530,
  DarkVividPink = 11342935,
  DarkGold = 12745742,
  DarkOrange = 11027200,
  DarkRed = 10038562,
  DarkGrey = 9936031,
  DarkerGrey = 8359053,
  LightGrey = 12370112,
  DarkNavy = 2899536,
  Blurple = 7506394,
  Greyple = 10070709,
  DarkButNotBlack = 2895667,
  NotQuiteBlack = 2303786
}

export type ColorResolvable = Color | keyof Color | number | string | [ number, number, number ];

export function makeSafeQuery(dict: Dictionary): Dictionary<string>;

/**
 * Parses a hex code or integer to a hex integer.
 * @param {ColorResolvable} hex The hex code to parse.
 * @returns {number}
 */
export function parseColor(hex: ColorResolvable): number;

/**
 * Returns an object without the provided keys.
 * @param {Dictionary} obj The object.
 * @param {string[]} keys The keys to exclude.
 */
export function exclude<O extends Dictionary, K extends keyof O>(obj: O, ...keys: K[]): Omit<O, K>;

/**
 * Alternative to Node's `path.basename`, removing query string after the extension if it exists.
 * @param {string} path Path to get the basename of
 * @param {string} [ext] File extension to remove
 * @see https://github.com/discordjs/discord.js/blob/master/src/util/Util.js#L483-L493
 */
export function basename(path: string, ext?: string): string;

/**
 * Handles all gateway events for the client.
 * @private
 */
export class DataManager {
  /**
   * The client instance.
   * @type {Client}
   */
  readonly client: Client;
  /**
   * The provided engines.
   * @type {CachingManager}
   */
  readonly cache: CachingManager;
  /**
   * The janitor instance.
   * @this {Janitor}
   */
  readonly janitor: Janitor;
  /**
   * The event stats.
   * @type {Collection<GatewayEvent, number>}
   */
  stats: Collection<GatewayEvent, number>;
  /**
   * The events to track, if any.
   * @type {Array<GatewayEvent> | "all"}
   */
  track: GatewayEvent[] | "all";
  /**
   * All events that won't be handled.
   * @type {Set<GatewayEvent>}
   */
  disabledEvents: Set<GatewayEvent>;
  /**
   * The options provided to the data manager.
   * @type {DataOptions}
   */
  options: Required<DataOptions>;


  /**
   * Creates a new Handlers instance.
   * @param {Client} client The client instance.
   * @param {DataOptions} [options={}]
   */
  constructor(client: Client, options?: DataOptions);

  /**
   * Initializes the packet handling system.
   */
  init(): Promise<void>;
}

export interface DataOptions {
  /**
   * Options for the default engine.
   * @types {CachingOptions}
   */
  caching?: CachingOptions;
  /**
   * The jobs for the janitor.
   * @type {JanitorJobs}
   */
  janitor?: JanitorJobs;
  /**
   * Events that wont be handled.
   * @type {Set<GatewayEvent> | GatewayEvent[]}
   */
  disabledEvents?: Set<GatewayEvent> | GatewayEvent[];
  /**
   * Tracks how many times a certain event is received.
   * @type {GatewayEvent[] | "all" | boolean}
   */
  track?: GatewayEvent[] | "all" | boolean;
}
